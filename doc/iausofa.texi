\input texinfo.tex
@c %**start of header
@setfilename iausofa.info
@settitle Standards of Fundamental Astronomy
@c %**end of header

@include version.texi
@include macros.texi

@macro sofa{}
@acronym{SOFA}
@end macro

@macro iau{}
@acronym{IAU}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Standards of Fundamental Astronomy

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    ATSOFA

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           atsofa

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, the
International Astronomical Union's @sofa{} Collection of libraries
repackaged using the @gnu{} Autotools.  The last time the maintainer
bothered to update this paragraph he had updated the distribution to:

@itemize
@item
The source code of @sofa{} libraries version: @samp{SOFA-Issue:
2013-12-02}.

@item
The original documentation of @sofa{} libraries version:
@samp{SOFA-Issue: 2013-12-02}.

@item
The reformatted Texinfo documentation of @sofa{} libraries version:
@samp{SOFA-Issue: 2012-03-01}.
@end itemize

@value{PACKAGE} is neither distributed, nor supported, nor endorsed by
the International Astronomical Union.  Any use of this pacakge should
comply with @sofa{}'s license and terms of use.  Especially, but not
exclusively, any published work or commercial products which includes
results achieved by using @value{PACKAGE} shall acknowledge that the
@sofa{} software was used in obtaining those results.

@noindent
Copyright @copyright{} International Astronomical Union Standards of
Fundamental Astronomy (@url{http://www.iausofa.org}).

The repackaging into @value{PACKAGE} is by @value{AUTHOR}
@value{AUTHOR_EMAIL}.
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* iausofa: (iausofa).           @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* intro::                       The @iau{} @sofa{} software libraries.
* astronomy::                   @sofa{} Astronomy Library.
* vector matrix::               @sofa{} Vector/Matrix Library.
* api::                         Functions.

Appendices

* board::                       @iau{} Standards of Fundamental
                                Astronomy Board.
* license::                     Package license.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


The International Astronomical Union's @sofa{} Collection consists of
two libraries of routines, one coded in Fortran 77 the other in
@acronym{ANSI} C.  There is a suite of vector/matrix routines and
various utilities that underpin the astronomy algorithms, which include
routines for the following:

@itemize
@item
Calendars.

@item
Time Scales.

@item
Earth rotation and sidereal time.

@item
Ephemerides (medium precision).

@item
Geocentric/geodetic transformations.

@item
Precession, nutation, polar motion.

@item
Star space motion.

@item
Star catalogue conversion.
@end itemize

This package makes use of the @gnu{} Autotools to allow easy
distribution and installation of @sofa{}.

@value{PACKAGE} is neither distributed, nor supported, nor endorsed by
the International Astronomical Union.  Any use of this pacakge should
comply with @sofa{}'s license and terms of use.  Especially, but not
exclusively, any published work or commercial products which includes
results achieved by using @value{PACKAGE} shall acknowledge that the
@sofa{} software was used in obtaining those results.

@c page
@node intro
@chapter The @iau{} @sofa{} software libraries


@sofa{} stands for ``Standards Of Fundamental Astronomy''.  The @sofa{}
software libraries are a collection of subprograms, in source code form,
which implement official @iau{} algorithms for fundamental astronomy
computations.  The subprograms at present comprise 131 ''astronomy''
routines supported by 55 ``vector/matrix'' routines, available in both
Fortran77 and C implementations.

@c ------------------------------------------------------------

@section The @sofa{} initiative

@sofa{} is an @iau{} Service which operates under Division 1
(Fundamental Astronomy) and reports through Commission 19 (Rotation of
the Earth).

The @iau{} set up the @sofa{} initiative at the 1994 General Assembly,
to promulgate an authoritative set of fundamental astronomy constants
and algorithms.  At the subsequent General Assembly, in 1997, the
appointment of a @sofa{} Review Board and the selection of a site for
the @sofa{} Center (the outlet for @sofa{} products) were announced.

The @sofa{} initiative was originally proposed by the @iau{} Working
Group on Astronomical Standards (@acronym{WGAS}), under the chairmanship
of Toshio Fukushima.  The proposal was for ``@dots{}new arrangements to
establish and maintain an accessible and authoritative set of constants,
algorithms and procedures that implement standard models used in
fundamental astronomy''.  The @sofa{} Software Libraries implement the
``algorithms'' part of the @sofa{} initiative.  They were developed
under the supervision of an international panel called the @sofa{}
Review Board.  The current membership of this panel is listed in an
appendix.

A feature of the original @sofa{} software proposals was that the
products would be self--contained and not depend on other software.
This includes basic documentation, which, like the present file, will
mostly be plain @acronym{ASCII} text.  It should also be noted that
there is no assumption that the software will be used on a particular
computer and Operating System.  Although OS--related facilities may be
present (Unix make files for instance, use by the @sofa{} Center of
automatic code management systems, @acronym{HTML} versions of some
documentation), the routines themselves will be visible as individual
text files and will run on a variety of platforms.

@c ------------------------------------------------------------

@section Algorithms

The @sofa{} Review Board's initial goal has been to create a set of
callable subprograms.  Whether ``subroutines'' or ``functions'', they
are all referred to simply as ``routines''.  They are designed for use
by software developers wishing to write complete applications; no
runnable, free--standing applications are included in @sofa{}'s present
plans.

The algorithms are drawn from a variety of sources.  Because most of the
routines so far developed have either been standard ``text--book''
operations or implement well--documented standard algorithms, it has not
been necessary to invite the whole community to submit algorithms,
though consultation with authorities has occurred where necessary.  It
should also be noted that consistency with the conventions published by
the International Earth Rotation Service was a stipulation in the
original @sofa{} proposals, further constraining the software designs.
This state of affairs will continue to exist for some time, as there is
a large backlog of agreed extensions to work on.  However, in the future
the Board may decide to call for proposals, and is in the meantime
willing to look into any suggestions that are received by the @sofa{}
Center.

@c ------------------------------------------------------------

@section Scope

The routines currently available are listed in the next two chapters of
this document.

The ``astronomy'' library comprises 131 routines (plus one obsolete
Fortran routine that now appears under a revised name).  The areas
addressed include calendars, time scales, ephemerides,
precession--nutation, star space--motion, star catalog transformations
and geodetic/geocentric transformations.

The ``vector--matrix'' library, comprising 55 routines, contains a
collection of simple tools for manipulating the vectors, matrices and
angles used by the astronomy routines.

There is no explicit commitment by @sofa{} to support historical models,
though as time goes on a legacy of superseded models will naturally
accumulate.  There is, for example, no support of B1950/FK4 star
coordinates, or pre-1976 precession models, though these capabilities
could be added were there significant demand.

Though the @sofa{} software libraries are rather limited in scope, and
are likely to remain so for a considerable time, they do offer distinct
advantages to prospective users.  In particular, the routines are:

@itemize
@item
authoritative: they are @iau{}--backed and have been constructed with
great care;

@item
practical: they are straightforward to use in spite of being precise and
rigorous (to some stated degree);

@item
accessible and supported: they are downloadable from an easy--to--find
place, they are in an integrated and consistent form, they come with
adequate internal documentation, and help for users is available.
@end itemize

@c ------------------------------------------------------------

@section Versions

Once it has been published, an issue is never revised or updated, and
remains accessible indefinitely.  Subsequent issues may, however,
include corrected versions under the original routine name and
filenames.  However, where a different model is introduced, it will have
a different name.

The issues will be referred to by the date when they were announced.
The frequency of re--issue will be decided by the Board, taking into
account the importance of the changes and the impact on the user
community.

@c ------------------------------------------------------------

@section Documentation

At present there is little free--standing documentation about individual
routines.  However, each routine has preamble comments which specify in
detail what the routine does and how it is used.

The file @file{sofa_pn.pdf} describes the @sofa{} tools for
precession--nutation and other aspects of Earth attitude and includes
example code and (see the appendix) diagrams showing the
interrelationships between the routines supporting the latest (@iau{}
2006/2000A) models.

@c ------------------------------------------------------------

@section Programming languages and standards

The @sofa{} routines are available in two programming languages at
present: Fortran77 and ANSI C.  Related software in other languages is
under consideration.

The Fortran code conforms to @acronym{ANSI} X3.9-1978 in all but two
minor respects: each has an @code{IMPLICIT NONE} declaration, and its
name has a prefix of @code{iau_} and may be longer than 6 characters.  A
global edit to erase both of these will produce @code{ANSI}--compliant
code with no change in its function.

Coding style, and restrictions on the range of language features, have
been much debated by the Board, and the results comply with the majority
view.  There is (at present) no document that defines the standards, but
the code itself offers a wide range of examples of what is acceptable.

The Fortran routines contain explicit numerical constants (the
@code{INCLUDE} statement is not part of @acronym{ANSI} Fortran77).
These are drawn from the file @file{consts.lis}, which is listed in an
appendix.  Constants for the @sofa{}/C functions are defined in a header
file @file{sofam.h}.

The naming convention is such that a @sofa{} routine referred to
generically as @code{EXAMPL} exists as a Fortran subprogram
@code{iau_EXAMPL} and a C function @code{iauExampl}.  The calls for the
two versions are very similar, with the same arguments in the same
order.  In a few cases, the C equivalent of a Fortran @code{SUBROUTINE}
subprogram uses a return value rather than an argument.

Each language version includes a ``testbed'' main--program that can be
used to verify that the @sofa{} routines have been correctly compiled on
the end user's system.  The Fortran and C versions are called
@file{t_sofa_f.for} and @file{t_sofa_c.c} respectively.  The testbeds
execute every @sofa{} routine and check that the results are within
expected accuracy margins.  It is not possible to guarantee that all
platforms will meet the rather stringent criteria that have been used,
and an occasional warning message may be encountered on some systems.

@c ------------------------------------------------------------

@section Copyright issues

Copyright for all of the @sofa{} software and documentation is owned by
the @iau{} @sofa{} Review Board.  The Software is made available free of
charge for all classes of user, including commercial.  However, there
are strict rules designed to avoid unauthorized variants coming into
circulation.  It is permissible to distribute derived works and other
modifications, but they must be clearly marked to avoid confusion with
the @sofa{} originals.

Further details are included in the block of comments which concludes
every routine.  The text is also set out in an appendix to the present
document.

@c ------------------------------------------------------------

@section Accuracy

The @sofa{} policy is to organize the calculations so that the machine
accuracy is fully exploited.  The gap between the precision of the
underlying model or theory and the computational resolution has to be
kept as large as possible, hopefully leaving several orders of magnitude
of headroom.

The @sofa{} routines in some cases involve design compromises between
rigor and ease of use (and also speed, though nowadays this is seldom a
major concern).

@c ------------------------------------------------------------

@section Acknowledgements

The Board is indebted to a number of contributors, who are acknowledged
in the preamble comments of the routines concerned.

The Board's effort is provided by the members' individual institutes.

Resources for operating the @sofa{} Center are provided by Her Majesty's
Nautical Almanac Office, operated by the United Kingdom Hydrographic
Office.

@c page
@node astronomy
@chapter @sofa{} Astronomy Library


@section Preface

The routines described here comprise the @sofa{} astronomy library.
Their general appearance and coding style conforms to conventions agreed
by the @sofa{} Review Board, and their functions, names and algorithms
have been ratified by the Board.  Procedures for soliciting and agreeing
additions to the library are still evolving.

@c ------------------------------------------------------------

@section Programming languages

The @sofa{} routines are available in two programming languages at
present: Fortran 77 and @acronym{ANSI} C.

Except for a single obsolete Fortran routine, which has no C equivalent,
there is a one--to--one relationship between the two language versions.
The naming convention is such that a @sofa{} routine referred to
generically as @code{EXAMPL} exists as a Fortran subprogram
@code{iau_EXAMPL} and a C function @code{iauExampl}.  The calls for the
two versions are very similar, with the same arguments in the same
order.  In a few cases, the C equivalent of a Fortran @code{SUBROUTINE}
subprogram uses a return value rather than an argument.

@c ------------------------------------------------------------

@section General principles

The principal function of the @sofa{} Astronomy Library is to provide
definitive algorithms.  A secondary function is to provide software
suitable for convenient direct use by writers of astronomical
applications.

The astronomy routines call on the @sofa{} vector/matrix library
routines, which are separately listed.

The routines are designed to exploit the full floating--point accuracy
of the machines on which they run, and not to rely on compiler
optimizations.  Within these constraints, the intention is that the code
corresponds to the published formulation (if any).

Dates are always Julian Dates (except in calendar conversion routines)
and are expressed as two double precision numbers which sum to the
required value.

A distinction is made between routines that implement @iau{}--approved
models and those that use those models to create other results.  The
former are referred to as ``canonical models'' in the preamble comments;
the latter are described as ``support routines''.

Using the library requires knowledge of positional astronomy and
time--scales.  These topics are covered in ``Explanatory Supplement to
the Astronomical Almanac'', P. Kenneth Seidelmann (ed.), University
Science Books, 1992.  Recent developments are documented in the
journals, and references to the relevant papers are given in the @sofa{}
code as required.  The @acronym{IERS} Conventions are also an essential
reference.  The routines concerned with Earth attitude
(precession--nutation etc.)  are described in the @sofa{} document
@file{sofa_pn.pdf}.

@c ------------------------------------------------------------

@section Routines

Calendars:

@table @code
@item CAL2JD
Gregorian calendar to Julian Day number.

@item EPB
Julian Date to Besselian Epoch.

@item EPB2JD
Besselian Epoch to Julian Date.

@item EPJ
Julian Date to Julian Epoch.

@item EPJ2JD
Julian Epoch to Julian Date.

@item JD2CAL
Julian Date to Gregorian year, month, day, fraction.

@item JDCALF
Julian Date to Gregorian date for formatted output.
@end table

Time scales:

@table @code
@item D2DTF
Format 2-part JD for output.

@item DAT
Delta(AT) (=TAI-UTC) for a given UTC date.

@item DTDB
TDB-TT.

@item DTF2D
Encode time and date fields into 2-part JD.

@item TAITT
TAI to TT.

@item TAIUT1
TAI to UT1.

@item TAIUTC
TAI to UTC.

@item TCBTDB
TCB to TDB.

@item TCGTT
TCG to TT.

@item TDBTCB
TDB to TCB.

@item TDBTT
TDB to TT.

@item TTTAI
TT to TAI.

@item TTTCG
TT to TCG.

@item TTTDB
TT to TDB.

@item TTUT1
TT to UT1.

@item UT1TAI
UT1 to TAI.

@item UT1TT
UT1 to TT.

@item UT1UTC
UT1 to UTC.

@item UTCTAI
UTC to TAI.

@item UTCUT1
UTC to UT1.
@end table

Earth rotation angle and sidereal time:

@table @code
@item EE00
equation of the equinoxes, IAU 2000.

@item EE00A
equation of the equinoxes, IAU 2000A.

@item EE00B
equation of the equinoxes, IAU 2000B.

@item EE06A
equation of the equinoxes, IAU 2006/2000A.

@item EECT00
equation of the equinoxes complementary terms, IAU 2000.

@item EQEQ94
equation of the equinoxes, IAU 1994.

@item ERA00
Earth rotation angle, IAU 2000.

@item GMST00
Greenwich mean sidereal time, IAU 2000.

@item GMST06
Greenwich mean sidereal time, IAU 2006.

@item GMST82
Greenwich mean sidereal time, IAU 1982.

@item GST00A
Greenwich apparent sidereal time, IAU 2000A.

@item GST00B
Greenwich apparent sidereal time, IAU 2000B.

@item GST06
Greenwich apparent ST, IAU 2006, given NPB matrix.

@item GST06A
Greenwich apparent sidereal time, IAU 2006/2000A.

@item GST94
Greenwich apparent sidereal time, IAU 1994.

@end table

Ephemerides (limited precision):

@table @code
@item EPV00
Earth position and velocity.

@item PLAN94
major-planet position and velocity.
@end table

Precession, nutation, polar motion:

@table @code
@item BI00
frame bias components, IAU 2000.

@item BP00
frame bias and precession matrices, IAU 2000.

@item BP06
frame bias and precession matrices, IAU 2006.

@item BPN2XY
extract CIP X,Y coordinates from NPB matrix.

@item C2I00A
celestial-to-intermediate matrix, IAU 2000A.

@item C2I00B
celestial-to-intermediate matrix, IAU 2000B.

@item C2I06A
celestial-to-intermediate matrix, IAU 2006/2000A.

@item C2IBPN
celestial-to-intermediate matrix, given NPB matrix, IAU 2000.

@item C2IXY
celestial-to-intermediate matrix, given X,Y, IAU 2000.

@item C2IXYS
celestial-to-intermediate matrix, given X,Y and s.

@item C2T00A
celestial-to-terrestrial matrix, IAU 2000A.

@item C2T00B
celestial-to-terrestrial matrix, IAU 2000B.

@item C2T06A
celestial-to-terrestrial matrix, IAU 2006/2000A.

@item C2TCIO
form CIO-based celestial-to-terrestrial matrix.

@item C2TEQX
form equinox-based celestial-to-terrestrial matrix.

@item C2TPE
celestial-to-terrestrial matrix given nutation, IAU 2000.

@item C2TXY
celestial-to-terrestrial matrix given CIP, IAU 2000.

@item EO06A
equation of the origins, IAU 2006/2000A.

@item EORS
equation of the origins, given NPB matrix and s.

@item FW2M
Fukushima-Williams angles to r-matrix.

@item FW2XY
Fukushima-Williams angles to X,Y.

@item NUM00A
nutation matrix, IAU 2000A.

@item NUM00B
nutation matrix, IAU 2000B.

@item NUM06A
nutation matrix, IAU 2006/2000A.

@item NUMAT
form nutation matrix.

@item NUT00A
nutation, IAU 2000A.

@item NUT00B
nutation, IAU 2000B.

@item NUT06A
nutation, IAU 2006/2000A.

@item NUT80
nutation, IAU 1980.

@item NUTM80
nutation matrix, IAU 1980.

@item OBL06
mean obliquity, IAU 2006.

@item OBL80
mean obliquity, IAU 1980.

@item PB06
zeta,z,theta precession angles, IAU 2006, including bias.

@item PFW06
bias-precession Fukushima-Williams angles, IAU 2006.

@item PMAT00
precession matrix (including frame bias), IAU 2000.

@item PMAT06
PB matrix, IAU 2006.

@item PMAT76
precession matrix, IAU 1976.

@item PN00
bias/precession/nutation results, IAU 2000.

@item PN00A
bias/precession/nutation, IAU 2000A.

@item PN00B
bias/precession/nutation, IAU 2000B.

@item PN06
bias/precession/nutation results, IAU 2006.

@item PN06A
bias/precession/nutation results, IAU 2006/2000A.

@item PNM00A
classical NPB matrix, IAU 2000A.

@item PNM00B
classical NPB matrix, IAU 2000B.

@item PNM06A
classical NPB matrix, IAU 2006/2000A.

@item PNM80
precession/nutation matrix, IAU 1976/1980.

@item P06E
precession angles, IAU 2006, equinox based.

@item POM00
polar motion matrix.

@item PR00
IAU 2000 precession adjustments.

@item PREC76
accumulated precession angles, IAU 1976.

@item S00
the CIO locator s, given X,Y, IAU 2000A.

@item S00A
the CIO locator s, IAU 2000A.

@item S00B
the CIO locator s, IAU 2000B.

@item S06
the CIO locator s, given X,Y, IAU 2006.

@item S06A
the CIO locator s, IAU 2006/2000A.

@item SP00
the TIO locator s', IERS 2003.

@item XY06
CIP, IAU 2006/2000A, from series.

@item XYS00A
CIP and s, IAU 2000A.

@item XYS00B
CIP and s, IAU 2000B.

@item XYS06A
CIP and s, IAU 2006/2000A.
@end table

Fundamental arguments for nutation etc.

@table @code
@item FAD03
mean elongation of the Moon from the Sun.

@item FAE03
mean longitude of Earth.

@item FAF03
mean argument of the latitude of the Moon.

@item FAJU03
mean longitude of Jupiter.

@item FAL03
mean anomaly of the Moon.

@item FALP03
mean anomaly of the Sun.

@item FAMA03
mean longitude of Mars.

@item FAME03
mean longitude of Mercury.

@item FANE03
mean longitude of Neptune.

@item FAOM03
mean longitude of the Moon's ascending node.

@item FAPA03
general accumulated precession in longitude.

@item FASA03
mean longitude of Saturn.

@item FAUR03
mean longitude of Uranus.

@item FAVE03
mean longitude of Venus.

@end table

Star space motion:

@table @code
@item PVSTAR
space motion pv-vector to star catalog data.

@item STARPV
star catalog data to space motion pv-vector.
@end table

Star catalog conversions:

@table @code
@item FK52H
transform FK5 star data into the Hipparcos system.

@item FK5HIP
FK5 to Hipparcos rotation and spin.

@item FK5HZ
FK5 to Hipparcos assuming zero Hipparcos proper motion.

@item H2FK5
transform Hipparcos star data into the FK5 system.

@item HFK5Z
Hipparcos to FK5 assuming zero Hipparcos proper motion.

@item STARPM
proper motion between two epochs.
@end table

Geodetic/geocentric:

@table @code
@item EFORM
a,f for a nominated Earth reference ellipsoid.

@item GC2GD
geocentric to geodetic for a nominated ellipsoid.

@item GC2GDE
geocentric to geodetic given ellipsoid a,f.

@item GD2GC
geodetic to geocentric for a nominated ellipsoid.

@item GD2GCE
geodetic to geocentric given ellipsoid a,f.

@end table

Obsolete:

@table @code
@item C2TCEO
former name of C2TCIO.
@end table

Calls: Fortran version:

@smallexample
CALL iau_BI00   ( DPSIBI, DEPSBI, DRA )
CALL iau_BP00   ( DATE1, DATE2, RB, RP, RBP )
CALL iau_BP06   ( DATE1, DATE2, RB, RP, RBP )
CALL iau_BPN2XY ( RBPN, X, Y )
CALL iau_C2I00A ( DATE1, DATE2, RC2I )
CALL iau_C2I00B ( DATE1, DATE2, RC2I )
CALL iau_C2I06A ( DATE1, DATE2, RC2I )
CALL iau_C2IBPN ( DATE1, DATE2, RBPN, RC2I )
CALL iau_C2IXY  ( DATE1, DATE2, X, Y, RC2I )
CALL iau_C2IXYS ( X, Y, S, RC2I )
CALL iau_C2T00A ( TTA, TTB, UTA, UTB, XP, YP, RC2T )
CALL iau_C2T00B ( TTA, TTB, UTA, UTB, XP, YP, RC2T )
CALL iau_C2T06A ( TTA, TTB, UTA, UTB, XP, YP, RC2T )
CALL iau_C2TCEO ( RC2I, ERA, RPOM, RC2T )
CALL iau_C2TCIO ( RC2I, ERA, RPOM, RC2T )
CALL iau_C2TEQX ( RBPN, GST, RPOM, RC2T )
CALL iau_C2TPE  ( TTA, TTB, UTA, UTB, DPSI, DEPS, XP, YP, RC2T )
CALL iau_C2TXY  ( TTA, TTB, UTA, UTB, X, Y, XP, YP, RC2T )
CALL iau_CAL2JD ( IY, IM, ID, DJM0, DJM, J )
CALL iau_D2DTF  ( SCALE, NDP, D1, D2, IY, IM, ID, IHMSF, J )
CALL iau_DAT    ( IY, IM, ID, FD, DELTAT, J )
D =  iau_DTDB   ( DATE1, DATE2, UT, ELONG, U, V )
CALL iau_DTF2D  ( SCALE, IY, IM, ID, IHR, IMN, SEC, D1, D2, J )
D =  iau_EE00   ( DATE1, DATE2, EPSA, DPSI )
D =  iau_EE00A  ( DATE1, DATE2 )
D =  iau_EE00B  ( DATE1, DATE2 )
D =  iau_EE06A  ( DATE1, DATE2 )
D =  iau_EECT00 ( DATE1, DATE2 )
CALL iau_EFORM  ( N, A, F, J )
D =  iau_EO06A  ( DATE1, DATE2 )
D =  iau_EORS   ( RNPB, S )
D =  iau_EPB    ( DJ1, DJ2 )
CALL iau_EPB2JD ( EPB, DJM0, DJM )
D =  iau_EPJ    ( DJ1, DJ2 )
CALL iau_EPJ2JD ( EPJ, DJM0, DJM )
CALL iau_EPV00  ( DJ1, DJ2, PVH, PVB, J )
D =  iau_EQEQ94 ( DATE1, DATE2 )
D =  iau_ERA00  ( DJ1, DJ2 )
D =  iau_FAD03  ( T )
D =  iau_FAE03  ( T )
D =  iau_FAF03  ( T )
D =  iau_FAJU03 ( T )
D =  iau_FAL03  ( T )
D =  iau_FALP03 ( T )
D =  iau_FAMA03 ( T )
D =  iau_FAME03 ( T )
D =  iau_FANE03 ( T )
D =  iau_FAOM03 ( T )
D =  iau_FAPA03 ( T )
D =  iau_FASA03 ( T )
D =  iau_FAUR03 ( T )
D =  iau_FAVE03 ( T )
CALL iau_FK52H  ( R5, D5, DR5, DD5, PX5, RV5,
                   RH, DH, DRH, DDH, PXH, RVH )
CALL iau_FK5HIP ( R5H, S5H )
CALL iau_FK5HZ  ( R5, D5, DATE1, DATE2, RH, DH )
CALL iau_FW2M   ( GAMB, PHIB, PSI, EPS, R )
CALL iau_FW2XY  ( GAMB, PHIB, PSI, EPS, X, Y )
CALL iau_GC2GD  ( N, XYZ, ELONG, PHI, HEIGHT, J )
CALL iau_GC2GDE ( A, F, XYZ, ELONG, PHI, HEIGHT, J )
CALL iau_GD2GC  ( N, ELONG, PHI, HEIGHT, XYZ, J )
CALL iau_GD2GCE ( A, F, ELONG, PHI, HEIGHT, XYZ, J )
D =  iau_GMST00 ( UTA, UTB, TTA, TTB )
D =  iau_GMST06 ( UTA, UTB, TTA, TTB )
D =  iau_GMST82 ( UTA, UTB )
D =  iau_GST00A ( UTA, UTB, TTA, TTB )
D =  iau_GST00B ( UTA, UTB )
D =  iau_GST06  ( UTA, UTB, TTA, TTB, RNPB )
D =  iau_GST06A ( UTA, UTB, TTA, TTB )
D =  iau_GST94  ( UTA, UTB )
CALL iau_H2FK5  ( RH, DH, DRH, DDH, PXH, RVH,
                   R5, D5, DR5, DD5, PX5, RV5 )
CALL iau_HFK5Z  ( RH, DH, DATE1, DATE2, R5, D5, DR5, DD5 )
CALL iau_JD2CAL ( DJ1, DJ2, IY, IM, ID, FD, J )
CALL iau_JDCALF ( NDP, DJ1, DJ2, IYMDF, J )
CALL iau_NUM00A ( DATE1, DATE2, RMATN )
CALL iau_NUM00B ( DATE1, DATE2, RMATN )
CALL iau_NUM06A ( DATE1, DATE2, RMATN )
CALL iau_NUMAT  ( EPSA, DPSI, DEPS, RMATN )
CALL iau_NUT00A ( DATE1, DATE2, DPSI, DEPS )
CALL iau_NUT00B ( DATE1, DATE2, DPSI, DEPS )
CALL iau_NUT06A ( DATE1, DATE2, DPSI, DEPS )
CALL iau_NUT80  ( DATE1, DATE2, DPSI, DEPS )
CALL iau_NUTM80 ( DATE1, DATE2, RMATN )
D =  iau_OBL06  ( DATE1, DATE2 )
D =  iau_OBL80  ( DATE1, DATE2 )
CALL iau_PB06   ( DATE1, DATE2, BZETA, BZ, BTHETA )
CALL iau_PFW06  ( DATE1, DATE2, GAMB, PHIB, PSIB, EPSA )
CALL iau_PLAN94 ( DATE1, DATE2, NP, PV, J )
CALL iau_PMAT00 ( DATE1, DATE2, RBP )
CALL iau_PMAT06 ( DATE1, DATE2, RBP )
CALL iau_PMAT76 ( DATE1, DATE2, RMATP )
CALL iau_PN00   ( DATE1, DATE2, DPSI, DEPS,
                   EPSA, RB, RP, RBP, RN, RBPN )
CALL iau_PN00A  ( DATE1, DATE2,
                   DPSI, DEPS, EPSA, RB, RP, RBP, RN, RBPN )
CALL iau_PN00B  ( DATE1, DATE2,
                   DPSI, DEPS, EPSA, RB, RP, RBP, RN, RBPN )
CALL iau_PN06   ( DATE1, DATE2, DPSI, DEPS,
                   EPSA, RB, RP, RBP, RN, RBPN )
CALL iau_PN06A  ( DATE1, DATE2,
DPSI, DEPS, RB, RP, RBP, RN, RBPN )
CALL iau_PNM00A ( DATE1, DATE2, RBPN )
CALL iau_PNM00B ( DATE1, DATE2, RBPN )
CALL iau_PNM06A ( DATE1, DATE2, RNPB )
CALL iau_PNM80  ( DATE1, DATE2, RMATPN )
CALL iau_P06E   ( DATE1, DATE2,
                   EPS0, PSIA, OMA, BPA, BQA, PIA, BPIA,
                   EPSA, CHIA, ZA, ZETAA, THETAA, PA, GAM, PHI, PSI )
CALL iau_POM00  ( XP, YP, SP, RPOM )
CALL iau_PR00   ( DATE1, DATE2, DPSIPR, DEPSPR )
CALL iau_PREC76 ( EP01, EP02, EP11, EP12, ZETA, Z, THETA )
CALL iau_PVSTAR ( PV, RA, DEC, PMR, PMD, PX, RV, J )
D =  iau_S00    ( DATE1, DATE2, X, Y )
D =  iau_S00A   ( DATE1, DATE2 )
D =  iau_S00B   ( DATE1, DATE2 )
D =  iau_S06    ( DATE1, DATE2, X, Y )
D =  iau_S06A   ( DATE1, DATE2 )
D =  iau_SP00   ( DATE1, DATE2 )
CALL iau_STARPM ( RA1, DEC1, PMR1, PMD1, PX1, RV1,
                   EP1A, EP1B, EP2A, EP2B,
                   RA2, DEC2, PMR2, PMD2, PX2, RV2, J )
CALL iau_STARPV ( RA, DEC, PMR, PMD, PX, RV, PV, J )
CALL iau_TAITT  ( TAI1, TAI2, TT1, TT2, J )
CALL iau_TAIUT1 ( TAI1, TAI2, DTA, UT11, UT12, J )
CALL iau_TAIUTC ( TAI1, TAI2, UTC1, UTC2, J )
CALL iau_TCBTDB ( TCB1, TCB2, TDB1, TDB2, J )
CALL iau_TCGTT  ( TCG1, TCG2, TT1, TT2, J )
CALL iau_TDBTCB ( TDB1, TDB2, TCB1, TCB2, J )
CALL iau_TDBTT  ( TDB1, TDB2, DTR, TT1, TT2, J )
CALL iau_TTTAI  ( TT1, TT2, TAI1, TAI2, J )
CALL iau_TTTCG  ( TT1, TT2, TCG1, TCG2, J )
CALL iau_TTTDB  ( TT1, TT2, DTR, TDB1, TDB2, J )
CALL iau_TTUT1  ( TT1, TT2, DT, UT11, UT12, J )
CALL iau_UT1TAI ( UT11, UT12, TAI1, TAI2, J )
CALL iau_UT1TT  ( UT11, UT12, DT, TT1, TT2, J )
CALL iau_UT1UTC ( UT11, UT12, DUT, UTC1, UTC2, J )
CALL iau_UTCTAI ( UTC1, UTC2, DTA, TAI1, TAI2, J )
CALL iau_UTCUT1 ( UTC1, UTC2, DUT, UT11, UT12, J )
CALL iau_XY06   ( DATE1, DATE2, X, Y )
CALL iau_XYS00A ( DATE1, DATE2, X, Y, S )
CALL iau_XYS00B ( DATE1, DATE2, X, Y, S )
CALL iau_XYS06A ( DATE1, DATE2, X, Y, S )
@end smallexample

Calls: C version:

@smallexample
    iauBi00   ( &dpsibi, &depsbi, &dra );
    iauBp00   ( date1, date2, rb, rp, rbp );
    iauBp06   ( date1, date2, rb, rp, rbp );
    iauBpn2xy ( rbpn, &x, &y );
    iauC2i00a ( date1, date2, rc2i );
    iauC2i00b ( date1, date2, rc2i );
    iauC2i06a ( date1, date2, rc2i );
    iauC2ibpn ( date1, date2, rbpn, rc2i );
    iauC2ixy  ( date1, date2, x, y, rc2i );
    iauC2ixys ( x, y, s, rc2i );
    iauC2t00a ( tta, ttb, uta, utb, xp, yp, rc2t );
    iauC2t00b ( tta, ttb, uta, utb, xp, yp, rc2t );
    iauC2t06a ( tta, ttb, uta, utb, xp, yp, rc2t );
    iauC2tcio ( rc2i, era, rpom, rc2t );
    iauC2teqx ( rbpn, gst, rpom, rc2t );
    iauC2tpe  ( tta, ttb, uta, utb, dpsi, deps, xp, yp, rc2t );
    iauC2txy  ( tta, ttb, uta, utb, x, y, xp, yp, rc2t );
i = iauCal2jd ( iy, im, id, &djm0, &djm );
i = iauD2dtf  ( scale, ndp, d1, d2, &iy, &im, &id, ihmsf );

i = iauDat    ( iy, im, id, fd, &deltat );
d = iauDtdb   ( date1, date2, ut, elong, u, v );
i = iauDtf2d  ( scale, iy, im, id, ihr, imn, sec, &d1, &d2 );
d = iauEe00   ( date1, date2, epsa, dpsi );
d = iauEe00a  ( date1, date2 );
d = iauEe00b  ( date1, date2 );
d = iauEe06   ( date1, date2 );
d = iauEect00 ( date1, date2 );
i = iauEform  ( n, &a, &f );
d = iauEo06   ( date1, date2 );
d = iauEors   ( rnpb, s );
d = iauEpb    ( dj1, dj2 );
    iauEpb2jd ( epb, &djm0, &djm );
d = iauEpj    ( dj1, dj2 );
    iauEpj2jd ( epj, &djm0, &djm );
i = iauEpv00  ( dj1, dj2, pvh, pvb );
d = iauEqeq94 ( date1, date2 );
d = iauEra00  ( dj1, dj2 );
d = iauFad03  ( t );
d = iauFae03  ( t );
d = iauFaf03  ( t );
d = iauFaju03 ( t );
d = iauFal03  ( t );
d = iauFalp03 ( t );
d = iauFama03 ( t );
d = iauFame03 ( t );
d = iauFane03 ( t );
d = iauFaom03 ( t );
d = iauFapa03 ( t );
d = iauFasa03 ( t );
d = iauFaur03 ( t );
d = iauFave03 ( t );
    iauFk52h  ( r5, d5, dr5, dd5, px5, rv5,
                &rh, &dh, &drh, &ddh, &pxh, &rvh );
    iauFk5hip ( r5h, s5h );
    iauFk5hz  ( r5, d5, date1, date2, &rh, &dh );
    iauFw2m   ( gamb, phib, psi, eps, r );
    iauFw2xy  ( gamb, phib, psi, eps, &x, &y );
i = iauGc2gd  ( n, xyz, &elong, &phi, &height );
i = iauGc2gde ( a, f, xyz, &elong, &phi, &height );
i = iauGd2gc  ( n, elong, phi, height, xyz );
i = iauGd2gce ( a, f, elong, phi, height, xyz );
d = iauGmst00 ( uta, utb, tta, ttb );
d = iauGmst06 ( uta, utb, tta, ttb );
d = iauGmst82 ( uta, utb );
d = iauGst00a ( uta, utb, tta, ttb );
d = iauGst00b ( uta, utb );
d = iauGst06  ( uta, utb, tta, ttb, rnpb );
d = iauGst06a ( uta, utb, tta, ttb );
d = iauGst94  ( uta, utb );
    iauH2fk5  ( rh, dh, drh, ddh, pxh, rvh,
                &r5, &d5, &dr5, &dd5, &px5, &rv5 );
    iauHfk5z  ( rh, dh, date1, date2,
                &r5, &d5, &dr5, &dd5 );
i = iauJd2cal ( dj1, dj2, &iy, &im, &id, &fd );
i = iauJdcalf ( ndp, dj1, dj2, iymdf );
    iauNum00a ( date1, date2, rmatn );
    iauNum00b ( date1, date2, rmatn );
    iauNum06a ( date1, date2, rmatn );
    iauNumat  ( epsa, dpsi, deps, rmatn );
    iauNut00a ( date1, date2, &dpsi, &deps );
    iauNut00b ( date1, date2, &dpsi, &deps );
    iauNut06a ( date1, date2, &dpsi, &deps );
    iauNut80  ( date1, date2, &dpsi, &deps );
    iauNutm80 ( date1, date2, rmatn );
d = iauObl06  ( date1, date2 );
d = iauObl80  ( date1, date2 );
    iauPb06   ( date1, date2, &bzeta, &bz, &btheta );
    iauPfw06  ( date1, date2, &gamb, &phib, &psib, &epsa );
i = iauPlan94 ( date1, date2, np, pv );
    iauPmat00 ( date1, date2, rbp );
    iauPmat06 ( date1, date2, rbp );
    iauPmat76 ( date1, date2, rmatp );
    iauPn00   ( date1, date2, dpsi, deps,
                &epsa, rb, rp, rbp, rn, rbpn );
    iauPn00a  ( date1, date2,
                &dpsi, &deps, &epsa, rb, rp, rbp, rn, rbpn );
    iauPn00b  ( date1, date2,
                &dpsi, &deps, &epsa, rb, rp, rbp, rn, rbpn );
    iauPn06   ( date1, date2, dpsi, deps,
                &epsa, rb, rp, rbp, rn, rbpn );
    iauPn06a  ( date1, date2,
                &dpsi, &deps, &epsa, rb, rp, rbp, rn, rbpn );
    iauPnm00a ( date1, date2, rbpn );
    iauPnm00b ( date1, date2, rbpn );
    iauPnm06a ( date1, date2, rnpb );
    iauPnm80  ( date1, date2, rmatpn );
    iauP06e   ( date1, date2,
                &eps0, &psia, &oma, &bpa, &bqa, &pia, &bpia,
                &epsa, &chia, &za, &zetaa, &thetaa, &pa,
                &gam, &phi, &psi );
    iauPom00  ( xp, yp, sp, rpom );
    iauPr00   ( date1, date2, &dpsipr, &depspr );
    iauPrec76 ( ep01, ep02, ep11, ep12, &zeta, &z, &theta );
i = iauPvstar ( pv, &ra, &dec, &pmr, &pmd, &px, &rv );
d = iauS00    ( date1, date2, x, y );
d = iauS00a   ( date1, date2 );
d = iauS00b   ( date1, date2 );
d = iauS06    ( date1, date2, x, y );
d = iauS06a   ( date1, date2 );
d = iauSp00   ( date1, date2 );
i = iauStarpm ( ra1, dec1, pmr1, pmd1, px1, rv1,
                ep1a, ep1b, ep2a, ep2b,
                &ra2, &dec2, &pmr2, &pmd2, &px2, &rv2 );
i = iauStarpv ( ra, dec, pmr, pmd, px, rv, pv );
i = iauTaitt  ( tai1, tai2, &tt1, &tt2 );
i = iauTaiut1 ( tai1, tai2, dta, &ut11, &ut12 );
i = iauTaiutc ( tai1, tai2, &utc1, &utc2 );
i = iauTcbtdb ( tcb1, tcb2, &tdb1, &tdb2 );
i = iauTcgtt  ( tcg1, tcg2, &tt1, &tt2 );
i = iauTdbtcb ( tdb1, tdb2, &tcb1, &tcb2 );
i = iauTdbtt  ( tdb1, tdb2, dtr, &tt1, &tt2 );
i = iauTttai  ( tt1, tt2, &tai1, &tai2 );
i = iauTttcg  ( tt1, tt2, &tcg1, &tcg2 );
i = iauTttdb  ( tt1, tt2, dtr, &tdb1, &tdb2 );
i = iauTtut1  ( tt1, tt2, dt, &ut11, &ut12 );
i = iauUt1tai ( ut11, ut12, &tai1, &tai2 );
i = iauUt1tt  ( ut11, ut12, dt, &tt1, &tt2 );
i = iauUt1utc ( ut11, ut12, dut, &utc1, &utc2 );
i = iauUtctai ( utc1, utc2, dta, &tai1, &tai2 );
i = iauUtcut1 ( utc1, utc2, dut, &ut11, &ut12 );
    iauXy06   ( date1, date2, &x, &y );
    iauXys00a ( date1, date2, &x, &y, &s );
    iauXys00b ( date1, date2, &x, &y, &s );
    iauXys06a ( date1, date2, &x, &y, &s );
@end smallexample

@c page
@node vector matrix
@chapter @sofa{} Vector/Matrix Library


@section Preface

The routines described here comprise the @sofa{} vector/matrix library.
Their general appearance and coding style conforms to conventions agreed
by the @sofa{} Review Board, and their functions, names and algorithms
have been ratified by the Board.  Procedures for soliciting and agreeing
additions to the library are still evolving.

@c ------------------------------------------------------------

@section Programming languages

The @sofa{} routines are available in two programming languages at
present: Fortran 77 and ANSI C.

There is a one--to--one relationship between the two language versions.
The naming convention is such that a @sofa{} routine referred to
generically as @code{EXAMPL} exists as a Fortran subprogram
@code{iau_EXAMPL} and a C function @code{iauExampl}.  The calls for the
two versions are very similar, with the same arguments in the same
order.  In a few cases, the C equivalent of a Fortran @code{SUBROUTINE}
subprogram uses a return value rather than an argument.

@c ------------------------------------------------------------

@section General principles

The library consists mostly of routines which operate on ordinary
Cartesian vectors @math{(x, y, z)} and 3x3 rotation matrices.  However,
there is also support for vectors which represent velocity as well as
position and vectors which represent rotation instead of position.  The
vectors which represent both position and velocity may be considered
still to have dimensions @code{(3)}, but to comprise elements each of
which is two numbers, representing the value itself and the time
derivative.  Thus:

@itemize
@item
``Position'' or @code{p} vectors (or just plain @math{3}-vectors) have
dimension @code{(3)} in Fortran and @code{[3]} in C.

@item
``Position/velocity'' or @code{pv} vectors have dimensions @code{(3,2)}
in Fortran and @code{[2][3]} in C.

@item
``Rotation'' or @code{r} matrices have dimensions @code{(3,3)} in
Fortran and @code{[3][3]} in C.  When used for rotation, they are
``orthogonal''; the inverse of such a matrix is equal to the transpose.
Most of the routines in this library do not assume that
@code{r}-matrices are necessarily orthogonal and in fact work on any 3x3
matrix.

@item
``Rotation'' or @code{r} vectors have dimensions @code{(3)} in Fortran
and @code{[3]} in C.  Such vectors are a combination of the Euler axis
and angle and are convertible to and from @code{r}-matrices.  The
direction is the axis of rotation and the magnitude is the angle of
rotation, in radians.  Because the amount of rotation can be scaled up
and down simply by multiplying the vector by a scalar, @code{r}-vectors
are useful for representing spins about an axis which is fixed.

@item
The above rules mean that in terms of memory address, the three velocity
components of a @code{pv}-vector follow the three position components.
Application code is permitted to exploit this and all other knowledge of
the internal layouts: that @math{x}, @math{y} and @math{z} appear in
that order and are in a right--handed Cartesian coordinate system etc.
For example, the @code{cp} function (copy a @code{p}-vector) can be used
to copy the velocity component of a @code{pv}-vector (indeed, this is
how the @code{CPV} routine is coded).

@item
The routines provided do not completely fill the range of operations
that link all the various vector and matrix options, but are confined to
functions that are required by other parts of the @sofa{} software or
which are likely to prove useful.
@end itemize

In addition to the vector/matrix routines, the library contains some
routines related to spherical angles, including conversions to and from
sexagesimal format.

Using the library requires knowledge of vector/matrix methods, spherical
trigonometry, and methods of attitude representation.  These topics are
covered in many textbooks, including ``Spacecraft Attitude Determination
and Control'', James R. Wertz (ed.), Astrophysics and Space Science
Library, Vol. 73, D. Reidel Publishing Company, 1986.

@c ------------------------------------------------------------

@section Operations involving @code{p}-vectors and @code{r}-matrices

Initialize:

@table @code
@item ZP
zero @code{p}-vector.

@item ZR
initialize @code{r}-matrix to null.

@item IR
initialize @code{r}-matrix to identity.
@end table

Copy/extend/extract:

@table @code
@item CP
copy @code{p}-vector.

@item CR
copy @code{r}-matrix.
@end table

Build rotations:

@table @code
@item RX
rotate @code{r}-matrix about @math{x}.

@item RY
rotate @code{r}-matrix about @math{y}.

@item RZ
rotate @code{r}-matrix about @math{z}.
@end table

Spherical/Cartesian conversions:

@table @code
@item S2C
spherical to unit vector.

@item C2S
unit vector to spherical.

@item S2P
spherical to @code{p}-vector.

@item P2S
@code{p}-vector to spherical.
@end table

Operations on vectors:

@table @code
@item PPP
@code{p}-vector plus @code{p}-vector.

@item PMP
@code{p}-vector minus @code{p}-vector.

@item PPSP
@code{p}-vector plus scaled @code{p}-vector.

@item PDP
inner (=scalar=dot) product of two @code{p}-vectors.

@item PXP
outer (=vector=cross) product of two @code{p}-vectors.

@item PM
modulus of @code{p}-vector.

@item PN
normalize @code{p}-vector returning modulus.

@item SXP
multiply @code{p}-vector by scalar.
@end table

Operations on matrices:

@table @code
@item RXR
@code{r}-matrix multiply.

@item TR
transpose @code{r}-matrix.
@end table

Matrix--vector products:

@table @code
@item RXP
product of @code{r}-matrix and @code{p}-vector.

@item TRXP
product of transpose of @code{r}-matrix and @code{p}-vector.
@end table

Separation and position--angle:

@table @code
@item SEPP
angular separation from @code{p}-vectors.

@item SEPS
angular separation from spherical coordinates.

@item PAP
position--angle from @code{p}-vectors.

@item PAS
position--angle from spherical coordinates.
@end table

Rotation vectors:

@table @code
@item RV2M
@code{r}-vector to @code{r}-matrix.

@item RM2V
@code{r}-matrix to @code{r}-vector.
@end table

@c ------------------------------------------------------------

@section Operations involving @code{pv}-vectors

Initialize:

@table @code
@item ZPV
zero @code{pv}-vector.
@end table

Copy/extend/extract:

@table @code
@item CPV
copy @code{pv}-vector.

@item P2PV
append zero velocity to @code{p}-vector.

@item PV2P
discard velocity component of @code{pv}-vector.
@end table

Spherical/Cartesian conversions:

@table @code
@item S2PV
spherical to @code{pv}-vector.

@item PV2S
@code{pv}-vector to spherical.
@end table

Operations on vectors:

@table @code
@item PVPPV
@code{pv}-vector plus @code{pv}-vector.

@item PVMPV
@code{pv}-vector minus @code{pv}-vector.

@item PVDPV
inner (=scalar=dot) product of two @code{pv}-vectors.

@item PVXPV
outer (=vector=cross) product of two @code{pv}-vectors.

@item PVM
modulus of @code{pv}-vector.

@item SXPV
multiply @code{pv}-vector by scalar.

@item S2XPV
multiply @code{pv}-vector by two scalars.

@item PVU
update @code{pv}-vector.

@item PVUP
update @code{pv}-vector discarding velocity.
@end table

Matrix--vector products:

@table @code
@item RXPV
product of @code{r}-matrix and @code{pv}-vector.

@item TRXPV
product of transpose of @code{r}-matrix and @code{pv}-vector.
@end table

Operations on angles:

@table @code
@item ANP
normalize radians to range @code{0} to @code{2pi}.

@item ANPM
normalize radians to range @code{-pi} to @code{+pi}.

@item A2TF
decompose radians into hours, minutes, seconds.

@item A2AF
decompose radians into degrees, arcminutes, arcseconds.

@item AF2A
degrees, arcminutes, arcseconds to radians.

@item D2TF
decompose days into hours, minutes, seconds.

@item TF2A
hours, minutes, seconds to radians.

@item TF2D
hours, minutes, seconds to days.
@end table

Calls: Fortran version

@smallexample
CALL iau_A2AF  ( NDP, ANGLE, SIGN, IDMSF )
CALL iau_A2TF  ( NDP, ANGLE, SIGN, IHMSF )
CALL iau_AF2A  ( S, IDEG, IAMIN, ASEC, RAD, J )
D =  iau_ANP   ( A )
D =  iau_ANPM  ( A )
CALL iau_C2S   ( P, THETA, PHI )
CALL iau_CP    ( P, C )
CALL iau_CPV   ( PV, C )
CALL iau_CR    ( R, C )
CALL iau_D2TF  ( NDP, DAYS, SIGN, IHMSF )
CALL iau_IR    ( R )
CALL iau_P2PV  ( P, PV )
CALL iau_P2S   ( P, THETA, PHI, R )
CALL iau_PAP   ( A, B, THETA )
CALL iau_PAS   ( AL, AP, BL, BP, THETA )
CALL iau_PDP   ( A, B, ADB )
CALL iau_PM    ( P, R )
CALL iau_PMP   ( A, B, AMB )
CALL iau_PN    ( P, R, U )
CALL iau_PPP   ( A, B, APB )
CALL iau_PPSP  ( A, S, B, APSB )
CALL iau_PV2P  ( PV, P )
CALL iau_PV2S  ( PV, THETA, PHI, R, TD, PD, RD )
CALL iau_PVDPV ( A, B, ADB )
CALL iau_PVM   ( PV, R, S )
CALL iau_PVMPV ( A, B, AMB )
CALL iau_PVPPV ( A, B, APB )
CALL iau_PVU   ( DT, PV, UPV )
CALL iau_PVUP  ( DT, PV, P )
CALL iau_PVXPV ( A, B, AXB )
CALL iau_PXP   ( A, B, AXB )
CALL iau_RM2V  ( R, P )
CALL iau_RV2M  ( P, R )
CALL iau_RX    ( PHI, R )
CALL iau_RXP   ( R, P, RP )
CALL iau_RXPV  ( R, PV, RPV )
CALL iau_RXR   ( A, B, ATB )
CALL iau_RY    ( THETA, R )
CALL iau_RZ    ( PSI, R )
CALL iau_S2C   ( THETA, PHI, C )
CALL iau_S2P   ( THETA, PHI, R, P )
CALL iau_S2PV  ( THETA, PHI, R, TD, PD, RD, PV )
CALL iau_S2XPV ( S1, S2, PV )
CALL iau_SEPP  ( A, B, S )
CALL iau_SEPS  ( AL, AP, BL, BP, S )
CALL iau_SXP   ( S, P, SP )
CALL iau_SXPV  ( S, PV, SPV )
CALL iau_TF2A  ( S, IHOUR, IMIN, SEC, RAD, J )
CALL iau_TF2D  ( S, IHOUR, IMIN, SEC, DAYS, J )
CALL iau_TR    ( R, RT )
CALL iau_TRXP  ( R, P, TRP )
CALL iau_TRXPV ( R, PV, TRPV )
CALL iau_ZP    ( P )
CALL iau_ZPV   ( PV )
CALL iau_ZR    ( R )
@end smallexample

Calls: C version:

@smallexample
    iauA2af  ( ndp, angle, &sign, idmsf );
    iauA2tf  ( ndp, angle, &sign, ihmsf );
i = iauAf2a  ( s, ideg, iamin, asec, &rad );
d = iauAnp   ( a );
d = iauAnpm  ( a );
    iauC2s   ( p, &theta, &phi );
    iauCp    ( p, c );
    iauCpv   ( pv, c );
    iauCr    ( r, c );
    iauD2tf  ( ndp, days, &sign, ihmsf );
    iauIr    ( r );
    iauP2pv  ( p, pv );
    iauP2s   ( p, &theta, &phi, &r );
d = iauPap   ( a, b );
d = iauPas   ( al, ap, bl, bp );
d = iauPdp   ( a, b );
d = iauPm    ( p );
    iauPmp   ( a, b, amb );
    iauPn    ( p, &r, u );
    iauPpp   ( a, b, apb );
    iauPpsp  ( a, s, b, apsb );
    iauPv2p  ( pv, p );
    iauPv2s  ( pv, &theta, &phi, &r, &td, &pd, &rd );
    iauPvdpv ( a, b, adb );
    iauPvm   ( pv, &r, &s );
    iauPvmpv ( a, b, amb );
    iauPvppv ( a, b, apb );
    iauPvu   ( dt, pv, upv );
    iauPvup  ( dt, pv, p );
    iauPvxpv ( a, b, axb );
    iauPxp   ( a, b, axb );
    iauRm2v  ( r, p );
    iauRv2m  ( p, r );
    iauRx    ( phi, r );
    iauRxp   ( r, p, rp );
    iauRxpv  ( r, pv, rpv );
    iauRxr   ( a, b, atb );
    iauRy    ( theta, r );
    iauRz    ( psi, r );
    iauS2c   ( theta, phi, c );
    iauS2p   ( theta, phi, r, p );
    iauS2pv  ( theta, phi, r, td, pd, rd, pV );
    iauS2xpv ( s1, s2, pv );
d = iauSepp  ( a, b );
d = iauSeps  ( al, ap, bl, bp );
    iauSxp   ( s, p, sp );
    iauSxpv  ( s, pv, spv );
i = iauTf2a  ( s, ihour, imin, sec, &rad );
i = iauTf2d  ( s, ihour, imin, sec, &days );
    iauTr    ( r, rt );
    iauTrxp  ( r, p, trp );
    iauTrxpv ( r, pv, trpv );
    iauZp    ( p );
    iauZpv   ( pv );
    iauZr    ( r );
@end smallexample

@c page
@node api
@chapter Functions


@menu
* api astronomy::               Astronomy functions.
* api vector matrix::           Vector and matrix functions.
* api consts fortran::          Fortran language constants.
* api consts c::                C language constants.
@end menu

@c page
@node api astronomy
@section Astronomy functions


@menu
* api Calendars::               Calendars.
* api Ephemerides::             Ephemerides.
* api FundamentalArgs::         Fundamental args.
* api PrecNutPolar::            Prec nut polar.
* api RotationAndTime::         Rotation and time.
* api SpaceMotion::             Space motion.
* api StarCatalogs::            Star catalogs.
* api Geodetic/Geocentric::     Geodetic geocentric.
* api Timescales::              Timescales.
@end menu

@c page
@node api Calendars
@subsection Calendars


@deftypefun int iauCal2jd (int @var{iy}, int @var{im}, int @var{id}, double * @var{djm0}, double * @var{djm})
Gregorian Calendar to Julian Date.

Status: support function.

Given:

@example
iy,im,id  int     year, month, day in Gregorian calendar (Note 1)
@end example

Returned:

@example
djm0      double  MJD zero-point: always 2400000.5
djm       double  Modified Julian Date for 0 hrs
@end example

Returned (function value):

@example
int     status:
            0 = OK
           -1 = bad year   (Note 3: JD not computed)
           -2 = bad month  (JD not computed)
           -3 = bad day    (JD computed)
@end example

Notes:

@enumerate
@item
The algorithm used is valid from -4800 March 1, but this implementation
rejects dates before -4799 January 1.

@item
The Julian Date is returned in two pieces, in the usual SOFA manner,
which is designed to preserve time resolution.  The Julian Date is
available as a single number by adding @var{djm0} and @var{djm}.

@item
In early eras the conversion is from the ``Proleptic Gregorian
Calendar''; no account is taken of the date(s) of adoption of the
Gregorian Calendar, nor is the AD/BC numbering convention observed.
@end enumerate

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 12.92 (p604).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauEpb (double @var{dj1}, double @var{dj2})
Julian Date to Besselian Epoch.

Status: support function.

Given:

@example
dj1,dj2    double     Julian Date (see note)
@end example

Returned (function value):

@example
           double     Besselian Epoch.
@end example

Note:

@enumerate
@item
The Julian Date is supplied in two pieces, in the usual @sofa{} manner,
which is designed to preserve time resolution.  The Julian Date is
available as a single number by adding @var{dj1} and @var{dj2}.  The
maximum resolution is achieved if @var{dj1} is 2451545D0 (J2000.0).
@end enumerate

Reference:

@itemize
@item
Lieske,J.H., 1979. Astron.Astrophys.,73,282.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauEpb2jd (double @var{epb}, double * @var{djm0}, double * @var{djm})
Besselian Epoch to Julian Date.

Status: support function.

Given:

@example
epb      double    Besselian Epoch (e.g. 1957.3D0)
@end example

Returned:

@example
djm0     double    MJD zero-point: always 2400000.5
djm      double    Modified Julian Date
@end example

Note:

@enumerate
@item
The Julian Date is returned in two pieces, in the usual @sofa{} manner,
which is designed to preserve time resolution.  The Julian Date is
available as a single number by adding @var{djm0} and @var{djm}.
@end enumerate

Reference:

@itemize
@item
Lieske, J.H., 1979, Astron.Astrophys. 73, 282.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauEpj (double @var{dj1}, double @var{dj2})
Julian Date to Julian Epoch.

Status: support function.

Given:

@example
dj1,dj2    double     Julian Date (see note)
@end example

Returned (function value):

@example
           double     Julian Epoch
@end example

Note:

@enumerate
@item
The Julian Date is supplied in two pieces, in the usual @sofa{} manner,
which is designed to preserve time resolution.  The Julian Date is
available as a single number by adding @var{dj1} and @var{dj2}.  The
maximum resolution is achieved if @var{dj1} is 2451545D0 (J2000.0).
@end enumerate

Reference:

@itemize
@item
Lieske, J.H., 1979, Astron.Astrophys. 73, 282.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauEpj2jd (double @var{epj}, double * @var{djm0}, double * @var{djm})
Julian Epoch to Julian Date.

Status: support function.

Given:

@example
epj      double    Julian Epoch (e.g. 1996.8D0)
@end example

Returned:

@example
djm0     double    MJD zero-point: always 2400000.5
djm      double    Modified Julian Date
@end example

Note:

@enumerate
@item
The Julian Date is returned in two pieces, in the usual SOFA manner,
which is designed to preserve time resolution.  The Julian Date is
available as a single number by adding @var{djm0} and @var{djm}.
@end enumerate

Reference:

@itemize
@item
Lieske, J.H., 1979, Astron.Astrophys. 73, 282.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauJd2cal (double @var{dj1}, double @var{dj2}, int * @var{iy}, int * @var{im}, int * @var{id}, double * @var{fd})
Julian Date to Gregorian year, month, day, and fraction of a day.

Status: support function.

Given:

@example
dj1,dj2   double   Julian Date (Notes 1, 2)
@end example

Returned (arguments):

@example
iy        int      year
im        int      month
id        int      day
fd        double   fraction of day
@end example

Returned (function value):

@example
int      status:
            0 = OK
           -1 = unacceptable date (Note 3)
@end example

Notes:

@enumerate
@item
The earliest valid date is -68569.5 (-4900 March 1).  The largest value
accepted is 10^9.

@item
The Julian Date is apportioned in any convenient way between the
arguments @var{dj1} and @var{dj2}.  For example, @code{JD = 2450123.7}
could be expressed in any of these ways, among others:

@example
   dj1             dj2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

@item
In early eras the conversion is from the ``proleptic Gregorian
calendar''; no account is taken of the date(s) of adoption of the
Gregorian calendar, nor is the AD/BC numbering convention observed.
@end enumerate

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 12.92 (p604).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauJdcalf (int @var{ndp}, double @var{dj1}, double @var{dj2}, int @var{iymdf}[4])
Julian Date to Gregorian Calendar, expressed in a form convenient for
formatting messages: rounded to a specified precision.

Status: support function.

Given:

@example
ndp       int      number of decimal places of days in fraction
dj1,dj2   double   dj1+dj2 = Julian Date (Note 1)
@end example

Returned:

@example
iymdf     int[4]   year, month, day, fraction in Gregorian
                   calendar
@end example

Returned (function value):

@example
int      status:
           -1 = date out of range
            0 = OK
           +1 = NDP not 0-9 (interpreted as 0)
@end example

Notes:

@enumerate
@item
The Julian Date is apportioned in any convenient way between the
arguments @var{dj1} and @var{dj2}.  For example, @code{JD = 2450123.7}
could be expressed in any of these ways, among others:

@example
    dj1            dj2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

@item
In early eras the conversion is from the ``Proleptic Gregorian
Calendar''; no account is taken of the date(s) of adoption of the
Gregorian Calendar, nor is the AD/BC numbering convention observed.

@item
Refer to the function iauJd2cal.

@item
NDP should be 4 or less if internal overflows are to be avoided on
machines which use 16-bit integers.
@end enumerate

Called:

@table @code
@item iauJd2cal
JD to Gregorian calendar.
@end table

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 12.92 (p604).
@end itemize
@end deftypefun

@c page
@node api Ephemerides
@subsection Ephemerides


@deftypefun int iauEpv00 (double @vari{date}, double @varii{date}, double @var{pvh}[2][3], double @var{pvb}[2][3])
Earth position and velocity, heliocentric and barycentric, with respect
to the Barycentric Celestial Reference System.

Status: support function.

Given:

@example
date1,date2  double        TDB date (Note 1)
@end example

Returned:

@example
pvh          double[2][3]  heliocentric Earth position/velocity
pvb          double[2][3]  barycentric Earth position/velocity
@end example

Returned (function value):

@example
int           status: 0 = OK
                     +1 = warning: date outside
                          the range 1900-2100 AD
@end example

Notes:

@enumerate
@item
The TDB date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TDB) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.  However, the accuracy of the result is more likely to be
limited by the algorithm itself than the way the date has been
expressed.

@quotation
n.b. TT can be used instead of TDB in most applications.
@end quotation

@item
On return, the arrays @var{pvh} and @var{pvb} contain the following:

@example
pvh[0][0]  x       @}
pvh[0][1]  y       @} heliocentric position, AU
pvh[0][2]  z       @}

pvh[1][0]  xdot    @}
pvh[1][1]  ydot    @} heliocentric velocity, AU/d
pvh[1][2]  zdot    @}

pvb[0][0]  x       @}
pvb[0][1]  y       @} barycentric position, AU
pvb[0][2]  z       @}

pvb[1][0]  xdot    @}
pvb[1][1]  ydot    @} barycentric velocity, AU/d
pvb[1][2]  zdot    @}
@end example

The vectors are with respect to the Barycentric Celestial Reference
System.  The time unit is one day in TDB.

@item
The function is a @strong{simplified solution} from the planetary theory
VSOP2000 (X. Moisson, P. Bretagnon, 2001, Celes. Mechanics &
Dyn. Astron., 80, 3/4, 205-213) and is an adaptation of original Fortran
code supplied by P. Bretagnon (private comm., 2000).

@item
Comparisons over the time span 1900-2100 with this simplified solution
and the JPL DE405 ephemeris give the following results:

@example
                     RMS    max
Heliocentric:
   position error    3.7   11.2   km
   velocity error    1.4    5.0   mm/s

Barycentric:
   position error    4.6   13.4   km
   velocity error    1.4    4.9   mm/s
@end example

Comparisons with the JPL DE406 ephemeris show that by 1800 and 2200 the
position errors are approximately double their 1900-2100 size.  By 1500
and 2500 the deterioration is a factor of 10 and by 1000 and 3000 a
factor of 60.  The velocity accuracy falls off at about half that rate.

@item
It is permissible to use the same array for pvh and pvb, which will
receive the barycentric values.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauPlan94 (double @vari{date}, double @varii{date}, int @var{np}, double @var{pv}[2][3])
Approximate heliocentric position and velocity of a nominated major
planet: Mercury, Venus, EMB, Mars, Jupiter, Saturn, Uranus or Neptune
(but not the Earth itself).

Status: support function.

Given:

@example
date1  double       TDB date part A (Note 1)
date2  double       TDB date part B (Note 1)
np     int          planet (1=Mercury, 2=Venus, 3=EMB, 4=Mars,
                    5=Jupiter, 6=Saturn, 7=Uranus, 8=Neptune)
@end example

Returned (argument):

@example
pv     double[2][3] planet p,v (heliocentric, J2000.0, AU,AU/d)
@end example

Returned (function value):

@example
int          status: -1 = illegal NP (outside 1-8)
                      0 = OK
                     +1 = warning: year outside 1000-3000
                     +2 = warning: failed to converge
@end example

Notes:

@enumerate
@item
The date @code{@vari{date} + @varii{date}} is in the TDB time scale (in
practice TT can be used) and is a Julian Date, apportioned in any
convenient way between the two arguments.  For example, @code{JD(TDB) =
2450123.7} could be expressed in any of these ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.  The limited accuracy of the present algorithm is such that
any of the methods is satisfactory.

@item
If an @var{np} value outside the range 1-8 is supplied, an error status
(function value -1) is returned and the pv vector set to zeroes.

@item
For @code{@var{np} = 3} the result is for the Earth--Moon Barycenter.
To obtain the heliocentric position and velocity of the Earth, use
instead the @sofa{} function @code{iauEpv00}.

@item
On successful return, the array @var{pv} contains the following:

@example
pv[0][0]   x      @}
pv[0][1]   y      @} heliocentric position, AU
pv[0][2]   z      @}

pv[1][0]   xdot   @}
pv[1][1]   ydot   @} heliocentric velocity, AU/d
pv[1][2]   zdot   @}
@end example

The reference frame is equatorial and is with respect to the mean
equator and equinox of epoch J2000.0.

@item
The algorithm is due to J.L. Simon, P. Bretagnon, J. Chapront,
M. Chapront-Touze, G. Francou and J. Laskar (Bureau des Longitudes,
Paris, France).  From comparisons with JPL ephemeris DE102, they quote
the following maximum errors over the interval 1800-2050:

@example
             L (arcsec)    B (arcsec)      R (km)

Mercury          4             1             300
Venus            5             1             800
EMB              6             1            1000
Mars            17             1            7700
Jupiter         71             5           76000
Saturn          81            13          267000
Uranus          86             7          712000
Neptune         11             1          253000
@end example

Over the interval 1000-3000, they report that the accuracy is no worse
than 1.5 times that over 1800-2050.  Outside 1000-3000 the accuracy
declines.

Comparisons of the present function with the JPL DE200 ephemeris give
the following RMS errors over the interval 1960-2025:

@example
              position (km)     velocity (m/s)

Mercury            334               0.437
Venus             1060               0.855
EMB               2010               0.815
Mars              7690               1.98
Jupiter          71700               7.70
Saturn          199000              19.4
Uranus          564000              16.4
Neptune         158000              14.4
@end example

Comparisons against DE200 over the interval 1800-2100 gave the following
maximum absolute differences.  (The results using DE406 were essentially
the same.)

@example
           L (arcsec)   B (arcsec)     R (km)   Rdot (m/s)

Mercury        7            1            500       0.7
Venus          7            1           1100       0.9
EMB            9            1           1300       1.0
Mars          26            1           9000       2.5
Jupiter       78            6          82000       8.2
Saturn        87           14         263000      24.6
Uranus        86            7         661000      27.4
Neptune       11            2         248000      21.4
@end example

@item
The present @sofa{} re-implementation of the original Simon et al.
Fortran code differs from the original in the following respects:

@itemize
@item
C instead of Fortran.

@item
The date is supplied in two parts.

@item
The result is returned only in equatorial Cartesian form; the ecliptic
longitude, latitude and radius vector are not returned.

@item
The result is in the J2000.0 equatorial frame, not ecliptic.

@item
More is done in--line: there are fewer calls to subroutines.

@item
Different error/warning status values are used.

@item
A different Kepler's--equation--solver is used (avoiding use of double
precision complex).

@item
Polynomials in t are nested to minimize rounding errors.

@item
Explicit double constants are used to avoid mixed--mode expressions.
@end itemize

None of the above changes affects the result significantly.

@item
The returned status indicates the most serious condition encountered
during execution of the function.  Illegal np is considered the most
serious, overriding failure to converge, which in turn takes precedence
over the remote date warning.
@end enumerate

Called:

@table @code
@item iauAnp
Normalize angle into range 0 to 2pi.
@end table

Reference:

@itemize
Simon, J.L, Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., and Laskar, J., Astron. Astrophys. 282, 663 (1994).
@end itemize
@end deftypefun

@c page
@node api FundamentalArgs
@subsection Fundamental args


@deftypefun double iauFad03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean elongation of the
Moon from the Sun.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    D, radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003) and is from
Simon et al. (1994).
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFae03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean longitude of Earth.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    mean longitude of Earth, radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFaf03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean longitude of the
Moon minus mean longitude of the ascending node.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example


Returned (function value):

@example
      double    F, radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003) and is from
Simon et al. (1994).
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFaju03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean longitude of
Jupiter.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    mean longitude of Jupiter, radians (Note 2)
@end example

Notes:

@enumerate
@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.

@item
The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFal03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean anomaly of the Moon.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    l, radians (Note 2)
@end example

Notes:

@enumerate
@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.

@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFalp03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean anomaly of the Sun.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    l', radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003) and is from
Simon et al. (1994).
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFama03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean longitude of Mars.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    mean longitude of Mars, radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
@end enumerate

References:

@enumerate
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFame03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean longitude of
Mercury.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    mean longitude of Mercury, radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFane03 (double @var{t})
Fundamental argument, IERS Conventions (2003):
mean longitude of Neptune.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    mean longitude of Neptune, radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003) and is
adapted from Simon et al. (1994).
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFaom03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean longitude of the
Moon's ascending node.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    Omega, radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003) and is from
Simon et al. (1994).
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFapa03 (double @var{t})
Fundamental argument, IERS Conventions (2003): general accumulated
precession in longitude.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    general precession in longitude, radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003).  It is
taken from Kinoshita & Souchay (1990) and comes originally from Lieske
et al. (1977).
@end enumerate

References:

@itemize
@item
Kinoshita, H. and Souchay J. 1990, Celest.Mech. and Dyn.Astron.  48, 187.

@item
Lieske, J.H., Lederle, T., Fricke, W. & Morando, B. 1977,
Astron.Astrophys. 58, 1-16.

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFasa03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean longitude of Saturn.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    mean longitude of Saturn, radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFaur03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean longitude of Uranus.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned  (function value):

@example
      double    mean longitude of Uranus, radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003) and is
adapted from Simon et al. (1994).
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauFave03 (double @var{t})
Fundamental argument, IERS Conventions (2003): mean longitude of Venus.

Status: canonical model.

Given:

@example
t     double    TDB, Julian centuries since J2000.0 (Note 1)
@end example

Returned (function value):

@example
      double    mean longitude of Venus, radians (Note 2)
@end example

Notes:

@enumerate
@item
Though @var{t} is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

@item
The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.
@end itemize
@end deftypefun

@c page
@node api PrecNutPolar
@subsection Prec nut polar


@deftypefun void iauBi00 (double * @var{dpsibi}, double * @var{depsbi}, double * @var{dra})
Frame bias components of IAU 2000 precession--nutation models (part of
MHB2000 with additions).

Status: canonical model.

Returned:

@example
dpsibi,depsbi  double  longitude and obliquity corrections
dra            double  the ICRS RA of the J2000.0 mean equinox
@end example

Notes:

@enumerate
@item
The frame bias corrections in longitude and obliquity (radians) are
required in order to correct for the offset between the GCRS pole and
the mean J2000.0 pole.  They define, with respect to the GCRS frame, a
J2000.0 mean pole that is consistent with the rest of the IAU 2000A
precession--nutation model.

@item
In addition to the displacement of the pole, the complete description of
the frame bias requires also an offset in right ascension.  This is not
part of the IAU 2000A model, and is from Chapront et al. (2002).  It is
returned in radians.

@item
This is a supplemented implementation of one aspect of the IAU 2000A
nutation model, formally adopted by the IAU General Assembly in 2000,
namely MHB2000 (Mathews et al. 2002).
@end enumerate

References:

@itemize
@item
Chapront, J., Chapront-Touze, M. & Francou, G., Astron.
Astrophys., 387, 700, 2002.

@item
Mathews, P.M., Herring, T.A., Buffet, B.A., ``Modeling of nutation and
precession New nutation series for nonrigid Earth and insights into the
Earth's interior'', J.Geophys.Res., 107, B4, 2002.  The MHB2000 code
itself was obtained on 9th September 2002 from:

@center @url{ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A}
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauBp00 (double @vari{date}, double @varii{date}, double @var{rb}[3][3], double @var{rp}[3][3], double @var{rbp}[3][3])
Frame bias and precession, IAU 2000.

Status: canonical model.

Given:

@example
date1,date2  double         TT as a 2-part Julian Date (Note 1)
@end example

Returned:
@example
rb           double[3][3]   frame bias matrix (Note 2)
rp           double[3][3]   precession matrix (Note 3)
rbp          double[3][3]   bias-precession matrix (Note 4)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
    date1         date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix @var{rb} transforms vectors from GCRS to mean J2000.0 by
applying frame bias.

@item
The matrix @var{rp} transforms vectors from J2000.0 mean equator and
equinox to mean equator and equinox of date by applying precession.

@item
The matrix @var{rbp} transforms vectors from GCRS to mean equator and
equinox of date by applying frame bias then precession.  It is the
product @code{@var{rp} * @var{rb}}.

@item
It is permissible to reuse the same array in the returned arguments.
The arrays are filled in the order given.
@end enumerate

Called:

@table @code
@item iauBi00
Frame bias components, IAU 2000.

@item iauPr00
IAU 2000 precession adjustments.

@item iauIr
Initialize @code{r}-matrix to identity.

@item iauRx
Rotate around @math{x}-axis.

@item iauRy
Rotate around @math{y}-axis.

@item iauRz
Rotate around @math{z}-axis.

@item iauCr
Copy @code{r}-matrix.

@item iauRxr
Product of two @code{r}-matrices.
@end table

Reference:

@itemize
@item
``Expressions for the Celestial Intermediate Pole and Celestial
Ephemeris Origin consistent with the IAU 2000A precession--nutation
model'', Astron.Astrophys. 400, 1145-1154 (2003).

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed ``celestial
intermediate origin'' (CIO) by IAU 2006 Resolution 2.
@end quotation
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauBp06 (double @vari{date}, double @varii{date}, double @var{rb}[3][3], double @var{rp}[3][3], double @var{rbp}[3][3])
Frame bias and precession, IAU 2006.

Status: support function.

Given:

@example
date1,date2  double         TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rb           double[3][3]   frame bias matrix (Note 2)
rp           double[3][3]   precession matrix (Note 3)
rbp          double[3][3]   bias-precession matrix (Note 4)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
    date1         date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix @var{rb} transforms vectors from GCRS to mean J2000.0 by
applying frame bias.

@item
The matrix @var{rp} transforms vectors from mean J2000.0 to mean of date
by applying precession.

@item
The matrix @var{rbp} transforms vectors from GCRS to mean of date by
applying frame bias then precession.  It is the product @code{@var{rp} *
@var{rb}}.
@end enumerate

Called:

@table @code
@item iauPfw06
Bias--precession F-W angles, IAU 2006.

@item iauFw2m
F-W angles to @code{r}-matrix.

@item iauPmat06
PB matrix, IAU 2006.

@item iauTr
Transpose @code{r}-matrix.

@item iauRxr
Product of two @code{r}-matrices.
@end table

References:

@itemize
Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855.

@item
Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauBpn2xy (double @var{rbpn}[3][3], double * @var{x}, double * @var{y})
Extract from the bias--precession--nutation matrix the @math{x},
@math{y} coordinates of the Celestial Intermediate Pole.

Status: support function.

Given:

@example
rbpn      double[3][3]  celestial-to-true matrix (Note 1)
@end example

Returned:

@example
x,y       double        Celestial Intermediate Pole (Note 2)
@end example

Notes:

@enumerate
@item
The matrix rbpn transforms vectors from GCRS to true equator (and CIO or
equinox) of date, and therefore the Celestial Intermediate Pole unit
vector is the bottom row of the matrix.

@item
The arguments @var{x}, @var{y} are components of the Celestial
Intermediate Pole unit vector in the Geocentric Celestial Reference
System.
@end enumerate

Reference:

@itemize
@item
``Expressions for the Celestial Intermediate Pole and Celestial
Ephemeris Origin consistent with the IAU 2000A precession--nutation
model'', Astron.Astrophys. 400, 1145-1154 (2003)

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed "celestial
intermediate origin" (CIO) by IAU 2006 Resolution 2.
@end quotation
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2i00a (double @vari{date}, double @varii{date}, double @var{rc2i}[3][3])
Form the celestial--to--intermediate matrix for a given date using the
IAU 2000A precession-nutation model.

Status: support function.

Given:

@example
date1,date2 double       TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rc2i        double[3][3] celestial-to-intermediate matrix (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix @var{rc2i} is the first stage in the transformation from
celestial to terrestrial coordinates:

@example
[TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
      = rc2t * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), ERA is the Earth Rotation
Angle and RPOM is the polar motion matrix.

@item
A faster, but slightly less accurate result (about @math{1} mas), can be
obtained by using instead the @code{iauC2i00b} function.
@end enumerate

Called:

@table @code
@item iauPnm00a
Classical NPB matrix, IAU 2000A.

@item iauC2ibpn
Celestial--to--intermediate matrix, given NPB matrix.
@end table

References:

@itemize
@item
``Expressions for the Celestial Intermediate Pole and Celestial
Ephemeris Origin consistent with the IAU 2000A precession--nutation
model'', Astron.Astrophys. 400, 1145-1154 (2003)

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed ``celestial
intermediate originW'' (CIO) by IAU 2006 Resolution 2.
@end quotation

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2i00b (double @vari{date}, double @varii{date}, double @var{rc2i}[3][3])
Form the celestial--to--intermediate matrix for a given date using the
IAU 2000B precession-nutation model.

Status: support function.

Given:

@example
date1,date2 double       TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rc2i        double[3][3] celestial-to-intermediate matrix (Note 2)
@end example

Notes:

@enumerate
@item
The TT date date1+date2 is a Julian Date, apportioned in any convenient
way between the two arguments.  For example, @code{JD(TT) = 2450123.7}
could be expressed in any of these ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix @var{rc2i} is the first stage in the transformation from
celestial to terrestrial coordinates:

@example
[TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
      = rc2t * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), ERA is the Earth Rotation
Angle and RPOM is the polar motion matrix.

@item
The present function is faster, but slightly less accurate (about
@math{1} mas), than the @code{iauC2i00a} function.
@end enumerate

Called:

@table @code
@item iauPnm00b
Classical NPB matrix, IAU 2000B.

@item iauC2ibpn
Celestial--to--intermediate matrix, given NPB matrix.
@end table

References:

@itemize
@item
``Expressions for the Celestial Intermediate Pole and Celestial
Ephemeris Origin consistent with the IAU 2000A precession-nutation
model'', Astron.Astrophys. 400, 1145-1154 (2003)

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed ``celestial
intermediate origin'' (CIO) by IAU 2006 Resolution 2.
@end quotation

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2i06a (double @vari{date}, double @varii{date}, double @var{rc2i}[3][3])
Form the celestial--to--intermediate matrix for a given date using the
IAU 2006 precession and IAU 2000A nutation models.

Status: support function.

Given:

@example
date1,date2 double       TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rc2i        double[3][3] celestial-to-intermediate matrix (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix @var{rc2i} is the first stage in the transformation from
celestial to terrestrial coordinates:

@example
[TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
      = RC2T * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), ERA is the Earth Rotation
Angle and RPOM is the polar motion matrix.
@end enumerate

Called:

@table @code
@item iauPnm06a
Classical NPB matrix, IAU 2006/2000A.

@item iauBpn2xy
Extract CIP X,Y coordinates from NPB matrix.

@item iauS06
The CIO locator @math{s}, Given X,Y, IAU 2006.

@item iauC2ixys
Celestial--to--intermediate matrix, Given X,Y and s.
@end table

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2ibpn (double @vari{date}, double @varii{date}, double @var{rbpn}[3][3], double @var{rc2i}[3][3])
Form the celestial--to--intermediate matrix for a given date given the
bias--precession--nutation matrix.  IAU 2000.

Status: support function.

Given:

@example
date1,date2 double       TT as a 2-part Julian Date (Note 1)
rbpn        double[3][3] celestial-to-true matrix (Note 2)
@end example

Returned:

@example
rc2i        double[3][3] celestial-to-intermediate matrix (Note 3)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix @var{rbpn} transforms vectors from @acronym{GCRS} to true
equator (and CIO or equinox) of date.  Only the CIP (bottom row) is
used.

@item
The matrix @var{rc2i} is the first stage in the transformation from
celestial to terrestrial coordinates:

@example
[TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
      = RC2T * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), @code{ERA} is the Earth
Rotation Angle and @code{RPOM} is the polar motion matrix.

@item
Although its name does not include "00", This function is in fact
specific to the IAU 2000 models.
@end enumerate

Called:

@table @code
@item iauBpn2xy
Extract CIP X,Y coordinates from NPB matrix.

@item iauC2ixy
Celestial--to--intermediate matrix, given X,Y.
@end table

References:

@itemize
@item
``Expressions for the Celestial Intermediate Pole and Celestial
Ephemeris Origin consistent with the IAU 2000A precession-nutation
model'', Astron.Astrophys. 400, 1145-1154 (2003).

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed ``celestial
intermediate origin'' (CIO) by IAU 2006 Resolution 2.
@end quotation

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2ixy (double @vari{date}, double @varii{date}, double @var{x}, double @var{y}, double @var{rc2i}[3][3])
Form the celestial to intermediate--frame--of--date matrix for a given
date when the CIP X,Y coordinates are known.  IAU 2000.

Status: support function.

Given:

@example
date1,date2 double       TT as a 2-part Julian Date (Note 1)
x,y         double       Celestial Intermediate Pole (Note 2)
@end example

Returned:

@example
rc2i        double[3][3] celestial-to-intermediate matrix (Note 3)
@end example

Notes:

@itemize
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The Celestial Intermediate Pole coordinates are the @var{x}, @var{y}
components of the unit vector in the Geocentric Celestial Reference
System.

@item
The matrix @var{rc2i} is the first stage in the transformation from
celestial to terrestrial coordinates:

@example
[TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
      = RC2T * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), @code{ERA} is the Earth
Rotation Angle and @code{RPOM} is the polar motion matrix.

@item
Although its name does not include @code{00}, this function is in fact
specific to the IAU 2000 models.
@end itemize

Called:

@table @code
@item iauC2ixys
Celestial--to--intermediate matrix, given X,Y and s.

@item iauS00
The CIO locator @math{s}, given X,Y, IAU 2000A.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2ixys (double @var{x}, double @var{y}, double @var{s}, double @var{rc2i}[3][3])
Form the celestial to intermediate--frame--of--date matrix given the CIP
@var{x}, @var{y} and the CIO locator @var{s}.

Status: support function.

Given:

@example
x,y      double         Celestial Intermediate Pole (Note 1)
s        double         the CIO locator @math{s} (Note 2)
@end example

Returned:

@example
rc2i     double[3][3]   celestial-to-intermediate matrix (Note 3)
@end example

Notes:

@itemize
@item
The Celestial Intermediate Pole coordinates are the @var{x}, @var{y}
components of the unit vector in the Geocentric Celestial Reference
System.

@item
The CIO locator @var{s} (in radians) positions the Celestial
Intermediate Origin on the equator of the CIP.

@item
The matrix @var{rc2i} is the first stage in the transformation from
celestial to terrestrial coordinates:

@example
[TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
      = RC2T * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), @code{ERA} is the Earth
Rotation Angle and @code{RPOM} is the polar motion matrix.
@end itemize

Called:

@table @code
@item iauIr
Initialize @code{r}-matrix to identity.

@item iauRz
Rotate around @math{Z}-axis.

@item iauRy
Rotate around @math{Y}-axis.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2t00a (double @var{tta}, double @var{ttb}, double @var{uta}, double @var{utb}, double @var{xp}, double @var{yp}, double @var{rc2t}[3][3])
Form the celestial to terrestrial matrix given the date, the UT1 and the
polar motion, using the IAU 2000A nutation model.

Status: support function.

Given:

@example
tta,ttb  double         TT as a 2-part Julian Date (Note 1)
uta,utb  double         UT1 as a 2-part Julian Date (Note 1)
xp,yp    double         coordinates of the pole (radians, Note 2)
@end example

Returned:

@example
rc2t     double[3][3]   celestial-to-terrestrial matrix (Note 3)
@end example

Notes:

@enumerate
@item
The TT and UT1 dates @code{@var{tta} + @var{ttb}} and @code{@var{uta} +
@var{utb}} are Julian Dates, apportioned in any convenient way between
the arguments @var{uta} and @var{utb}.  For example, @code{JD(UT1) =
2450123.7} could be expressed in any of these ways, among others:

@example
    uta            utb

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  In the case of @var{uta}, @var{utb}, the date & time
method is best matched to the Earth rotation angle algorithm used:
maximum precision is delivered when the uta argument is for 0hrs UT1 on
the day in question and the @var{utb} argument lies in the range
@math{0} to @math{1}, or vice versa.

@item
The arguments @var{xp} and @var{yp} are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to @math{0} and @math{90} deg west respectively.

@item
The matrix @var{rc2t} transforms from celestial to terrestrial
coordinates:

@example
[TRS] = RPOM * R_3(ERA) * RC2I * [CRS]
      = rc2t * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), @code{RC2I} is the
celestial--to--intermediate matrix, @code{ERA} is the Earth rotation
angle and @code{RPOM} is the polar motion matrix.

@item
A faster, but slightly less accurate result (about @math{1} mas), can be
obtained by using instead the @code{iauC2t00b} function.
@end enumerate

Called:

@table @code
@item iauC2i00a
Celestial--to--intermediate matrix, IAU 2000A.

@item iauEra00
Earth rotation angle, IAU 2000.

@item iauSp00
The TIO locator s', IERS 2000.

@item iauPom00
Polar motion matrix.

@item iauC2tcio
Form CIO-based celestial--to--terrestrial matrix.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2t00b (double @var{tta}, double @var{ttb}, double @var{uta}, double @var{utb}, double @var{xp}, double @var{yp}, double @var{rc2t}[3][3])
Form the celestial to terrestrial matrix given the date, the UT1 and the
polar motion, using the IAU 2000B nutation model.

Status: support function.

Given:

@example
tta,ttb  double         TT as a 2-part Julian Date (Note 1)
uta,utb  double         UT1 as a 2-part Julian Date (Note 1)
xp,yp    double         coordinates of the pole (radians, Note 2)
@end example

Returned:

@example
rc2t     double[3][3]   celestial-to-terrestrial matrix (Note 3)
@end example

Notes:

@enumerate
@item
The TT and UT1 dates @code{@var{tta} + @var{ttb}} and @code{@var{uta} +
@var{utb}} are Julian Dates, apportioned in any convenient way between
the arguments @var{uta} and @var{utb}.  For example, @code{JD(UT1) =
2450123.7} could be expressed in any of these ways, among others:

@example
    uta            utb

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  In the case of @var{uta}, @var{utb}, the date & time
method is best matched to the Earth rotation angle algorithm used:
maximum precision is delivered when the uta argument is for 0hrs UT1 on
the day in question and the @var{utb} argument lies in the range
@math{0} to @math{1}, or vice versa.

@item
The arguments @var{xp} and @var{yp} are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to @math{0} and @math{90} deg west respectively.

@item
The matrix @var{rc2t} transforms from celestial to terrestrial
coordinates:

@example
[TRS] = RPOM * R_3(ERA) * RC2I * [CRS]
      = rc2t * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), @code{RC2I} is the
celestial--to--intermediate matrix, @code{ERA} is the Earth rotation
angle and @code{RPOM} is the polar motion matrix.

@item
The present function is faster, but slightly less accurate (about
@math{1} mas), than the @code{iauC2t00a} function.
@end enumerate

Called:

@table @code
@item iauC2i00b
Celestial--to--intermediate matrix, IAU 2000B.

@item iauEra00
Earth rotation angle, IAU 2000.

@item iauPom00
Polar motion matrix.

@item iauC2tcio
Form CIO-based celestial--to--terrestrial matrix.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2t06a (double @var{tta}, double @var{ttb}, double @var{uta}, double @var{utb}, double @var{xp}, double @var{yp}, double @var{rc2t}[3][3])
Form the celestial to terrestrial matrix given the date, the UT1 and the
polar motion, using the IAU 2006 precession and IAU 2000A nutation
models.

Status: support function.

Given:

@example
tta,ttb  double         TT as a 2-part Julian Date (Note 1)
uta,utb  double         UT1 as a 2-part Julian Date (Note 1)
xp,yp    double         coordinates of the pole (radians, Note 2)
@end example

Returned:

@example
rc2t     double[3][3]   celestial-to-terrestrial matrix (Note 3)
@end example

Notes:

@enumerate
@item
The TT and UT1 dates @code{@var{tta} + @var{ttb}} and @code{@var{uta} +
@var{utb}} are Julian Dates, apportioned in any convenient way between
the arguments @var{uta} and @var{utb}.  For example, @code{JD(UT1) =
2450123.7} could be expressed in any of these ways, among others:

@example
    uta            utb

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  In the case of @var{uta}, @var{utb}, the date & time
method is best matched to the Earth rotation angle algorithm used:
maximum precision is delivered when the uta argument is for 0hrs UT1 on
the day in question and the @var{utb} argument lies in the range
@math{0} to @math{1}, or vice versa.

@item
The arguments @var{xp} and @var{yp} are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to @math{0} and @math{90} deg west respectively.

@item
The matrix @var{rc2t} transforms from celestial to terrestrial
coordinates:

@example
[TRS] = RPOM * R_3(ERA) * RC2I * [CRS]
      = rc2t * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), @code{RC2I} is the
celestial--to--intermediate matrix, @code{ERA} is the Earth rotation
angle and @code{RPOM} is the polar motion matrix.
@end enumerate

Called:

@table @code
@item iauC2i06a
Celestial--to--intermediate matrix, IAU 2006/2000A.

@item iauEra00
Earth rotation angle, IAU 2000.

@item iauSp00
The TIO locator s', IERS 2000.

@item iauPom00
Polar motion matrix.

@item iauC2tcio
Form CIO-based celestial--to--terrestrial matrix.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2tcio (double @var{rc2i}[3][3], double @var{era}, double @var{rpom}[3][3], double @var{rc2t}[3][3])
Assemble the celestial to terrestrial matrix from CIO-based components
(the celestial--to--intermediate matrix, the Earth Rotation Angle and
the polar motion matrix).

Status: support function.

Given:

@example
rc2i     double[3][3]    celestial-to-intermediate matrix
era      double          Earth rotation angle
rpom     double[3][3]    polar-motion matrix
@end example

Returned:

@example
rc2t     double[3][3]    celestial-to-terrestrial matrix
@end example

Notes:

@enumerate
@item
This function constructs the rotation matrix that transforms vectors in
the celestial system into vectors in the terrestrial system.  It does so
starting from precomputed components, namely the matrix which rotates
from celestial coordinates to the intermediate frame, the Earth rotation
angle and the polar motion matrix.  One use of the present function is
when generating a series of celestial--to--terrestrial matrices where
only the Earth Rotation Angle changes, avoiding the considerable
overhead of recomputing the precession--nutation more often than
necessary to achieve given accuracy objectives.

@item
The relationship between the arguments is as follows:

@example
[TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
      = rc2t * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003).
@end enumerate

Called:

@table @code
@item iauCr
Copy @code{r}-matrix.

@item iauRz
Rotate around @math{Z}-axis.

@item iauRxr
Product of two @code{r}-matrices.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2teqx (double @var{rbpn}[3][3], double @var{gst}, double @var{rpom}[3][3], double @var{rc2t}[3][3])
Assemble the celestial to terrestrial matrix from equinox-based
components (the celestial--to--true matrix, the Greenwich Apparent
Sidereal Time and the polar motion matrix).

Status: support function.

Given:

@example
rbpn     double[3][3]    celestial-to-true matrix
gst      double          Greenwich (apparent) Sidereal Time
rpom     double[3][3]    polar-motion matrix
@end example

Returned:

@example
rc2t     double[3][3]    celestial-to-terrestrial matrix (Note 2)
@end example

Notes:

@enumerate
@item
This function constructs the rotation matrix that transforms vectors in
the celestial system into vectors in the terrestrial system.  It does so
starting from precomputed components, namely the matrix which rotates
from celestial coordinates to the true equator and equinox of date, the
Greenwich Apparent Sidereal Time and the polar motion matrix.  One use
of the present function is when generating a series of
celestial--to--terrestrial matrices where only the Sidereal Time
changes, avoiding the considerable overhead of recomputing the
precession-nutation more often than necessary to achieve given accuracy
objectives.

@item
The relationship between the arguments is as follows:

@example
[TRS] = rpom * R_3(gst) * rbpn * [CRS]
      = rc2t * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003).
@end enumerate

Called:

@table @code
@item iauCr
Copy @code{r}-matrix.

@item iauRz
Rotate around @math{Z}-axis.

@item iauRxr
Product of two @code{r}-matrices.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2tpe (double @var{tta}, double @var{ttb}, double @var{uta}, double @var{utb}, double @var{dpsi}, double @var{deps}, double @var{xp}, double @var{yp}, double @var{rc2t}[3][3])
Form the celestial to terrestrial matrix given the date, the UT1, the
nutation and the polar motion.  IAU 2000.

Status: support function.

Given:

@example
tta,ttb    double        TT as a 2-part Julian Date (Note 1)
uta,utb    double        UT1 as a 2-part Julian Date (Note 1)
dpsi,deps  double        nutation (Note 2)
xp,yp      double        coordinates of the pole (radians, Note 3)
@end example

Returned:

@example
rc2t       double[3][3]  celestial-to-terrestrial matrix (Note 4)
@end example

Notes:

@enumerate
@item
The TT and UT1 dates @code{@var{tta} + @var{ttb}} and @code{@var{uta} +
@var{utb}} are Julian Dates, apportioned in any convenient way between
the arguments @var{uta} and @var{utb}.  For example, @code{JD(UT1) =
2450123.7} could be expressed in any of these ways, among others:

@example
    uta            utb

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  In the case of @var{uta}, @var{utb}, the date & time
method is best matched to the Earth rotation angle algorithm used:
maximum precision is delivered when the uta argument is for 0hrs UT1 on
the day in question and the @var{utb} argument lies in the range
@math{0} to @math{1}, or vice versa.

@item
The caller is responsible for providing the nutation components; they
are in longitude and obliquity, in radians and are with respect to the
equinox and ecliptic of date.  For high--accuracy applications, free
core nutation should be included as well as any other relevant
corrections to the position of the CIP.

@item
The arguments @var{xp} and @var{yp} are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to @math{0} and @math{90} deg west respectively.

@item
The matrix @var{rc2t} transforms from celestial to terrestrial coordinates:

@example
[TRS] = RPOM * R_3(GST) * RBPN * [CRS]
      = rc2t * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), @code{RBPN} is the
bias--precession--nutation matrix, @code{GST} is the Greenwich
(apparent) Sidereal Time and @code{RPOM} is the polar motion matrix.

@item
Although its name does not include @code{00}, this function is in fact
specific to the IAU 2000 models.
@end enumerate

Called:

@table @code
@item iauPn00
Bias/precession/nutation results, IAU 2000.

@item iauGmst00
Greenwich mean sidereal time, IAU 2000.

@item iauSp00
The TIO locator s', IERS 2000.

@item iauEe00
Equation of the equinoxes, IAU 2000.

@item iauPom00
Polar motion matrix.

@item iauC2teqx
Form equinox--based celestial--to--terrestrial matrix.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauC2txy (double @var{tta}, double @var{ttb}, double @var{uta}, double @var{utb}, double @var{x}, double @var{y}, double @var{xp}, double @var{yp}, double @var{rc2t}[3][3])
Form the celestial to terrestrial matrix given the date, the UT1, the
CIP coordinates and the polar motion.  IAU 2000.

Status: support function.

Given:

@example
tta,ttb  double         TT as a 2-part Julian Date (Note 1)
uta,utb  double         UT1 as a 2-part Julian Date (Note 1)
x,y      double         Celestial Intermediate Pole (Note 2)
xp,yp    double         coordinates of the pole (radians, Note 3)
@end example

Returned:

@example
rc2t     double[3][3]   celestial-to-terrestrial matrix (Note 4)
@end example

Notes:

@enumerate
@item
The TT and UT1 dates @code{@var{tta} + @var{ttb}} and @code{@var{uta} +
@var{utb}} are Julian Dates, apportioned in any convenient way between
the arguments @var{uta} and @var{utb}.  For example, @code{JD(UT1) =
2450123.7} could be expressed in any o these ways, among others:

@example
    uta            utb

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  In the case of @var{uta}, @var{utb}, the date & time
method is best matched to the Earth rotation angle algorithm used:
maximum precision is delivered when the @var{uta} argument is for 0hrs
UT1 on the day in question and the @var{utb} argument lies in the range
@math{0} to @math{1}, or vice versa.

@item
The Celestial Intermediate Pole coordinates are the @math{x}, @math{y}
components of the unit vector in the Geocentric Celestial Reference
System.

@item
The arguments @var{xp} and @var{yp} are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to @math{0} and @math{90} deg west respectively.

@item
The matrix @var{rc2t} transforms from celestial to terrestrial coordinates:

@example
[TRS] = RPOM * R_3(ERA) * RC2I * [CRS]
      = rc2t * [CRS]
@end example

@noindent
where @code{[CRS]} is a vector in the Geocentric Celestial Reference
System and @code{[TRS]} is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), @code{ERA} is the Earth
Rotation Angle and @code{RPOM} is the polar motion matrix.

@item
Although its name does not include @code{00}, this function is in fact
specific to the IAU 2000 models.
@end enumerate

Called:

@table @code
@item iauC2ixy
Celestial--to--intermediate matrix, given @math{X}, @math{Y}.

@item iauEra00
Earth rotation angle, IAU 2000.

@item iauSp00
The TIO locator s', IERS 2000.

@item iauPom00
Polar motion matrix.

@item iauC2tcio
Form CIO-based celestial--to--terrestrial matrix.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauEo06a (double @vari{date}, double @varii{date})
Equation of the origins, IAU 2006 precession and IAU 2000A nutation.

Status: support function.

Given:

@example
date1,date2  double    TT as a 2-part Julian Date (Note 1)
@end example

Returned (function value):

@example
             double    equation of the origins in radians
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The equation of the origins is the distance between the true equinox and
the celestial intermediate origin and, equivalently, the difference
between Earth rotation angle and Greenwich apparent sidereal time
(ERA-GST).  It comprises the precession (since J2000.0) in right
ascension plus the equation of the equinoxes (including the small
correction terms).
@end enumerate

Called:

@table @code
@item iauPnm06a
Classical NPB matrix, IAU 2006/2000A.

@item iauBpn2xy
Extract CIP X,Y coordinates from NPB matrix.

@item iauS06
The CIO locator @math{s}, given X,Y, IAU 2006.

@item iauEors
Equation of the origins, Given NPB matrix and s.
@end table

References:

@itemize
@item
Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855

@item
Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauEors (double @var{rnpb}[3][3], double @var{s})
Equation of the origins, given the classical NPB matrix and the quantity
@var{s}.

Status: support function.

Given:
@example
rnpb  double[3][3]  classical nutation x precession x bias matrix
s     double        the quantity s (the CIO locator)
@end example

Returned (function value):

@example
      double        the equation of the origins in radians.
@end example

Notes:

@enumerate
@item
The equation of the origins is the distance between the true equinox and
the celestial intermediate origin and, equivalently, the difference
between Earth rotation angle and Greenwich apparent sidereal time
(ERA-GST).  It comprises the precession (since J2000.0) in right
ascension plus the equation of the equinoxes (including the small
correction terms).

@item
The algorithm is from Wallace & Capitaine (2006).
@end enumerate

References:

@itemize
@item
Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855

@item
Wallace, P. & Capitaine, N., 2006, Astron.Astrophys. 459, 981.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauFw2m (double @var{gamb}, double @var{phib}, double @var{psi}, double @var{eps}, double r[3][3])
Form rotation matrix given the Fukushima--Williams angles.

Status: support function.

Given:

@example
gamb     double         F-W angle gamma_bar (radians)
phib     double         F-W angle phi_bar (radians)
psi      double         F-W angle psi (radians)
eps      double         F-W angle epsilon (radians)
@end example

Returned:

@example
r        double[3][3]   rotation matrix
@end example

Notes:

@enumerate
@item
Naming the following points:

@example
e = J2000.0 ecliptic pole,
p = GCRS pole,
E = ecliptic pole of date,
P = CIP,
@end example

@noindent
the four Fukushima--Williams angles are as follows:

@example
gamb = gamma   = epE
phib = phi     = pE
psi  = psi     = pEP
eps  = epsilon = EP
@end example

@item
The matrix representing the combined effects of frame bias, precession
and nutation is:

@example
NxPxB = R_1(-eps).R_3(-psi).R_1(phib).R_3(gamb)
@end example

@item
Three different matrices can be constructed, depending on the supplied
angles:

@itemize
@item
To obtain the nutation x precession x frame bias matrix, generate the
four precession angles, generate the nutation components and add them to
the psi_bar and epsilon_A angles, and call the present function.

@item
To obtain the precession x frame bias matrix, generate the four
precession angles and call the present function.

@item
To obtain the frame bias matrix, generate the four precession angles for
date J2000.0 and call the present function.
@end itemize

The nutation--only and precession--only matrices can if necessary be
obtained by combining these three appropriately.
@end enumerate

Called:

@table @code
@item iauIr
Initialize @code{r}-matrix to identity.

@item iauRz
Rotate around @math{Z}-axis.

@item iauRx
Rotate around @math{X}-axis.
@end table

Reference:

@itemize
@item
Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauFw2xy (double @var{gamb}, double @var{phib}, double @var{psi}, double @var{eps}, double * @var{x}, double * @var{y})
CIP X,Y given Fukushima--Williams bias--precession--nutation angles.

Status: support function.

Given:

@example
gamb     double    F-W angle gamma_bar (radians)
phib     double    F-W angle phi_bar (radians)
psi      double    F-W angle psi (radians)
eps      double    F-W angle epsilon (radians)
@end example

Returned:

@example
x,y      double    CIP X,Y ("radians")
@end example

Notes:

@enumerate
@item
Naming the following points:

@example
e = J2000.0 ecliptic pole,
p = GCRS pole
E = ecliptic pole of date,
P = CIP,
@end example

@item
the four Fukushima--Williams angles are as follows:

@example
gamb = gamma   = epE
phib = phi     = pE
psi  = psi     = pEP
eps  = epsilon = EP
@end example

@item
The matrix representing the combined effects of frame bias, precession
and nutation is:

@example
NxPxB = R_1(-epsA).R_3(-psi).R_1(phib).R_3(gamb)
@end example

@noindent
@math{X},@math{Y} are elements @math{(3,1)} and @math{(3,2)} of the
matrix.
@end enumerate

Called:

@table @code
@item iauFw2m
F-W angles to @code{r}-matrix.

@item iauBpn2xy
Extract CIP X,Y coordinates from NPB matrix.
@end table

Reference:

@itemize
@item
Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauNum00a (double @vari{date}, double @varii{date}, double @var{rmatn}[3][3])
Form the matrix of nutation for a given date, IAU 2000A model.

Status: support function.

Given:

@example
date1,date2  double          TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rmatn        double[3][3]    nutation matrix
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix operates in the sense @code{V(true) = rmatn * V(mean)}, where
the @code{p}-vector @code{V(true)} is with respect to the true
equatorial triad of date and the @code{p}-vector @code{V(mean)} is with
respect to the mean equatorial triad of date.

@item
A faster, but slightly less accurate result (about 1 mas), can be
obtained by using instead the iauNum00b function.
@end enumerate

Called:

@table @code
@item iauPn00a
Bias/precession/nutation, IAU 2000A.
@end table

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.222-3
(p114).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauNum00b (double @vari{date}, double @varii{date}, double @var{rmatn}[3][3])
Form the matrix of nutation for a given date, IAU 2000B model.

Status: support function.

Given:

@example
date1,date2  double         TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rmatn        double[3][3]   nutation matrix
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix operates in the sense @code{V(true) = rmatn * V(mean)}, where
the @code{p}-vector @code{V(true)} is with respect to the true
equatorial triad of date and the @code{p}-vector @code{V(mean)} is with
respect to the mean equatorial triad of date.

@item
The present function is faster, but slightly less accurate (about
@math{1} mas), than the iauNum00a function.
@end enumerate

Called:

@table @code
@item iauPn00b
Bias/precession/nutation, IAU 2000B.
@end table

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.222-3
(p114).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauNum06a (double @vari{date}, double @varii{date}, double @var{rmatn}[3][3])
Form the matrix of nutation for a given date, IAU 2006/2000A model.

Status: support function.

Given:

@example
date1,date2   double          TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rmatn         double[3][3]    nutation matrix
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix operates in the sense @code{V(true) = rmatn * V(mean)}, where
the @code{p}-vector @code{V(true)} is with respect to the true
equatorial triad of date and the @code{p}-vector @code{V(mean)} is with
respect to the mean equatorial triad of date.
@end enumerate

Called:

@table @code
@item iauObl06
Mean obliquity, IAU 2006.

@item iauNut06a
Nutation, IAU 2006/2000A.

@item iauNumat
Form nutation matrix.
@end table

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.222-3
(p114).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauNumat (double @var{epsa}, double @var{dpsi}, double @var{deps}, double @var{rmatn}[3][3])
Form the matrix of nutation.

Status: support function.

Given:

@example
epsa        double         mean obliquity of date (Note 1)
dpsi,deps   double         nutation (Note 2)
@end example

Returned:

@example
rmatn       double[3][3]   nutation matrix (Note 3)
@end example

Notes:

@enumerate
@item
The supplied mean obliquity @var{epsa}, must be consistent with the
precession--nutation models from which dpsi and deps were obtained.

@item
The caller is responsible for providing the nutation components; they
are in longitude and obliquity, in radians and are with respect to the
equinox and ecliptic of date.

@item
The matrix operates in the sense @code{V(true) = rmatn * V(mean)}, where
the @code{p}-vector @code{V(true)} is with respect to the true
equatorial triad of date and the @code{p}-vector @code{V(mean)} is with
respect to the mean equatorial triad of date.
@end enumerate

Called:

@table @code
@item iauIr
Initialize @code{r}-matrix to identity.

@item iauRx
Rotate around @math{X}-axis.

@item iauRz
Rotate around @math{Z}-axis.
@end table

Reference:

@itemize
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.222-3
(p114).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauNut00a (double @vari{date}, double @varii{date}, double * @var{dpsi}, double * @var{deps})
Nutation, IAU 2000A model (MHB2000 luni-solar and planetary nutation
with free core nutation omitted).

Status: canonical model.

Given:

@example
date1,date2   double   TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
dpsi,deps     double   nutation, luni-solar + planetary (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The nutation components in longitude and obliquity are in radians and
with respect to the equinox and ecliptic of date.  The obliquity at
J2000.0 is assumed to be the Lieske et al. (1977) value of 84381.448
arcsec.

Both the luni--solar and planetary nutations are included.  The latter
are due to direct planetary nutations and the perturbations of the lunar
and terrestrial orbits.

@item
The function computes the MHB2000 nutation series with the associated
corrections for planetary nutations.  It is an implementation of the
nutation part of the IAU 2000A precession--nutation model, formally
adopted by the IAU General Assembly in 2000, namely MHB2000 (Mathews et
al. 2002), but with the free core nutation (FCN --- see Note 4) omitted.

@item
The full MHB2000 model also contains contributions to the nutations in
longitude and obliquity due to the free-excitation of the
free--core--nutation during the period 1979-2000.  These FCN terms,
which are time--dependent and unpredictable, are NOT included in the
present function and, if required, must be independently computed.  With
the FCN corrections included, the present function delivers a pole which
is at current epochs accurate to a few hundred microarcseconds.  The
omission of FCN introduces further errors of about that size.

@item
The present function provides classical nutation.  The MHB2000
algorithm, from which it is adapted, deals also with (i) the offsets
between the GCRS and mean poles and (ii) the adjustments in longitude
and obliquity due to the changed precession rates.  These additional
functions, namely frame bias and precession adjustments, are supported
by the SOFA functions iauBi00 and iauPr00.

@item
The MHB2000 algorithm also provides ``total'' nutations, comprising the
arithmetic sum of the frame bias, precession adjustments, luni-solar
nutation and planetary nutation.  These total nutations can be used in
combination with an existing IAU 1976 precession implementation, such as
iauPmat76, to deliver GCRS- to-true predictions of sub-mas accuracy at
current dates.  However, there are three shortcomings in the MHB2000
model that must be taken into account if more accurate or definitive
results are required (see Wallace 2002):

@enumerate a
@item
The MHB2000 total nutations are simply arithmetic sums, yet in reality
the various components are successive Euler rotations.  This slight lack
of rigor leads to cross terms that exceed 1 mas after a century.  The
rigorous procedure is to form the GCRS-to-true rotation matrix by
applying the bias, precession and nutation in that order.

@item
Although the precession adjustments are stated to be with respect to
Lieske et al. (1977), the MHB2000 model does not specify which set of
Euler angles are to be used and how the adjustments are to be applied.
The most literal and straightforward procedure is to adopt the
4-rotation epsilon_0, psi_A, omega_A, xi_A option, and to add DPSIPR to
psi_A and DEPSPR to both omega_A and eps_A.

@item
The MHB2000 model predates the determination by Chapront et al. (2002)
of a 14.6 mas displacement between the J2000.0 mean equinox and the
origin of the ICRS frame.  It should, however, be noted that neglecting
this displacement when calculating star coordinates does not lead to a
14.6 mas change in right ascension, only a small second- order
distortion in the pattern of the precession-nutation effect.
@end enumerate

For these reasons, the SOFA functions do not generate the ``total
nutations'' directly, though they can of course easily be generated by
calling iauBi00, iauPr00 and the present function and adding the
results.

@item
The MHB2000 model contains 41 instances where the same frequency appears
multiple times, of which 38 are duplicates and three are triplicates.
To keep the present code close to the original MHB algorithm, this small
inefficiency has not been corrected.
@end enumerate

Called:

@table @code
@item iauFal03
Mean anomaly of the Moon.

@item iauFaf03
Mean argument of the latitude of the Moon.

@item iauFaom03
Mean longitude of the Moon's ascending node.

@item iauFame03
Mean longitude of Mercury.

@item iauFave03
Mean longitude of Venus.

@item iauFae03
Mean longitude of Earth.

@item iauFama03
Mean longitude of Mars.

@item iauFaju03
Mean longitude of Jupiter.

@item iauFasa03
Mean longitude of Saturn.

@item iauFaur03
Mean longitude of Uranus.

@item iauFapa03
General accumulated precession in longitude.
@end table

References:

@itemize
@item
Chapront, J., Chapront-Touze, M. & Francou, G. 2002,
Astron.Astrophys. 387, 700

@item
Lieske, J.H., Lederle, T., Fricke, W. & Morando, B. 1977,
Astron.Astrophys. 58, 1-16

@item
Mathews, P.M., Herring, T.A., Buffet, B.A. 2002, J.Geophys.Res.  107,
B4.  The MHB_2000 code itself was obtained on 9th September 2002 from:

@center @url{ftp//maia.usno.navy.mil/conv2000/chapter5/IAU2000A}

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.

@item
Wallace, P.T., ``Software for Implementing the IAU 2000 Resolutions'',
in IERS Workshop 5.1 (2002).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauNut00b (double @vari{date}, double @varii{date}, double * @var{dpsi}, double * @var{deps})
Nutation, IAU 2000B model.

Status: canonical model.

Given:

@example
date1,date2   double    TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
dpsi,deps     double    nutation, luni-solar + planetary (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The nutation components in longitude and obliquity are in radians and
with respect to the equinox and ecliptic of date.  The obliquity at
J2000.0 is assumed to be the Lieske et al. (1977) value of 84381.448
arcsec.  (The errors that result from using this function with the IAU
2006 value of 84381.406 arcsec can be neglected.)

The nutation model consists only of luni--solar terms, but includes also
a fixed offset which compensates for certain long--period planetary
terms (Note 7).

@item
This function is an implementation of the IAU 2000B abridged nutation
model formally adopted by the IAU General Assembly in 2000.  The
function computes the MHB_2000_SHORT luni--solar nutation series (Luzum
2001), but without the associated corrections for the precession rate
adjustments and the offset between the GCRS and J2000.0 mean poles.

@item
The full IAU 2000A (MHB2000) nutation model contains nearly 1400 terms.
The IAU 2000B model (McCarthy & Luzum 2003) contains only 77 terms, plus
additional simplifications, yet still delivers results of 1 mas accuracy
at present epochs.  This combination of accuracy and size makes the IAU
2000B abridged nutation model suitable for most practical applications.

The function delivers a pole accurate to 1 mas from 1900 to 2100
(usually better than 1 mas, very occasionally just outside 1 mas).  The
full IAU 2000A model, which is implemented in the function iauNut00a
(q.v.), delivers considerably greater accuracy at current dates;
however, to realize this improved accuracy, corrections for the
essentially unpredictable free-core-nutation (FCN) must also be
included.

@item
The present function provides classical nutation.  The MHB_2000_SHORT
algorithm, from which it is adapted, deals also with (i) the offsets
between the GCRS and mean poles and (ii) the adjustments in longitude
and obliquity due to the changed precession rates.  These additional
functions, namely frame bias and precession adjustments, are supported
by the SOFA functions iauBi00 and iauPr00.

@item
The MHB_2000_SHORT algorithm also provides ``total'' nutations,
comprising the arithmetic sum of the frame bias, precession adjustments,
and nutation (luni-solar + planetary).  These total nutations can be
used in combination with an existing IAU 1976 precession implementation,
such as @code{iauPmat76}, to deliver GCRS--to--true predictions of mas
accuracy at current epochs.  However, for symmetry with the iauNut00a
function (q.v. for the reasons), the @sofa{} functions do not generate
the ``total nutations'' directly.  Should they be required, they could
of course easily be generated by calling @code{iauBi00}, @code{iauPr00}
and the present function and adding the results.

@item
The IAU 2000B model includes ``planetary bias'' terms that are fixed in
size but compensate for long-period nutations.  The amplitudes quoted in
McCarthy & Luzum (2003), namely @code{Dpsi = -1.5835 mas} and
@code{Depsilon = +1.6339 mas}, are optimized for the ``total nutations''
method described in Note 6.  The Luzum (2001) values used in this SOFA
implementation, namely -0.135 mas and +0.388 mas, are optimized for the
``rigorous'' method, where frame bias, precession and nutation are
applied separately and in that order.  During the interval 1995-2050,
the @sofa{} implementation delivers a maximum error of 1.001 mas (not
including FCN).
@end enumerate

References:

@itemize
@item
Lieske, J.H., Lederle, T., Fricke, W., Morando, B., ``Expressions for
the precession quantities based upon the IAU /1976/ system of
astronomical constants'', Astron.Astrophys. 58, 1-2, 1-16. (1977).

@item
Luzum, B., private communication, 2001 (Fortran code MHB_2000_SHORT).

@item
McCarthy, D.D. & Luzum, B.J., ``An abridged model of the
precession--nutation of the celestial pole'', Cel.Mech.Dyn.Astron.  85,
37-49 (2003).

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J., Astron.Astrophys. 282, 663-683 (1994).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauNut06a (double @vari{date}, double @varii{date}, double * @var{dpsi}, double * @var{deps})
IAU 2000A nutation with adjustments to match the IAU 2006 precession.

Status: canonical model.

Given:

@example
date1,date2   double   TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
dpsi,deps     double   nutation, luni-solar + planetary (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The nutation components in longitude and obliquity are in radians and
with respect to the mean equinox and ecliptic of date, IAU 2006
precession model (Hilton et al. 2006, Capitaine et al.  2005).

@item
The function first computes the IAU 2000A nutation, then applies
adjustments for (i) the consequences of the change in obliquity from the
IAU 1980 ecliptic to the IAU 2006 ecliptic and (ii) the secular
variation in the Earth's dynamical form factor J2.

@item
The present function provides classical nutation, complementing the IAU
2000 frame bias and IAU 2006 precession.  It delivers a pole which is at
current epochs accurate to a few tens of microarcseconds, apart from the
free core nutation.
@end enumerate

Called:

@table @code
@item iauNut00a
Nutation, IAU 2000A.
@end table

References:

@itemize
@item
Chapront, J., Chapront-Touze, M. & Francou, G. 2002,
Astron.Astrophys. 387, 700

@item
Lieske, J.H., Lederle, T., Fricke, W. & Morando, B. 1977,
Astron.Astrophys. 58, 1-16

@item
Mathews, P.M., Herring, T.A., Buffet, B.A. 2002, J.Geophys.Res.  107,
B4.  The MHB_2000 code itself was obtained on 9th September 2002 from:

@center @url{ftp//maia.usno.navy.mil/conv2000/chapter5/IAU2000A}

@item
Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.

@item
Wallace, P.T., ``Software for Implementing the IAU 2000 Resolutions'',
in IERS Workshop 5.1 (2002).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauNut80 (double @vari{date}, double @varii{date}, double * @var{dpsi}, double * @var{deps})
Nutation, IAU 1980 model.

Status: canonical model.

Given:

@example
date1,date2   double    TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
dpsi          double    nutation in longitude (radians)
deps          double    nutation in obliquity (radians)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The nutation components are with respect to the ecliptic of date.
@end enumerate

Called:

@table @code
@item iauAnpm
Normalize angle into range +/- pi.
@end table

Reference:

@itemize
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.222 (p111).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauNutm80 (double @vari{date}, double @varii{date}, double @var{rmatn}[3][3])
Form the matrix of nutation for a given date, IAU 1980 model.

Status: support function.

Given:

@example
date1,date2    double          TDB date (Note 1)
@end example

Returned:

@example
rmatn          double[3][3]    nutation matrix
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix operates in the sense @code{V(true) = rmatn * V(mean)}, where
the @code{p}-vector @code{V(true)} is with respect to the true
equatorial triad of date and the @code{p}-vector @code{V(mean)} is with
respect to the mean equatorial triad of date.
@end enumerate

Called:

@table @code
@item iauNut80
Nutation, IAU 1980.

@item iauObl80
Mean obliquity, IAU 1980.

@item iauNumat
Form nutation matrix.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauObl06 (double @vari{date}, double @varii{date})
Mean obliquity of the ecliptic, IAU 2006 precession model.

Status: canonical model.

Given:

@example
date1,date2  double   TT as a 2-part Julian Date (Note 1)
@end example

Returned (function value):

@example
double   obliquity of the ecliptic (radians, Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The result is the angle between the ecliptic and mean equator of date
@code{@vari{date} + @varii{date}}.
@end enumerate

Reference:

@itemize
@item
Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauObl80 (double @vari{date}, double @varii{date})
Mean obliquity of the ecliptic, IAU 1980 model.

Status: canonical model.

Given:

@example
date1,date2   double    TT as a 2-part Julian Date (Note 1)
@end example

Returned (function value):

@example
              double    obliquity of the ecliptic (radians, Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The result is the angle between the ecliptic and mean equator of date
@code{@vari{date} + @varii{date}}.
@end enumerate

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Expression 3.222-1
(p114).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauP06e (double @vari{date}, double @varii{date}, double * @var{eps0}, double * @var{psia}, double * @var{oma}, double * @var{bpa}, double * @var{bqa}, double * @var{pia}, double * @var{bpia}, double * @var{epsa}, double * @var{chia}, double * @var{za}, double * @var{zetaa}, double * @var{thetaa}, double * @var{pa}, double * @var{gam}, double * @var{phi}, double * @var{psi})
Precession angles, IAU 2006, equinox based.

Status: canonical models.

Given:

@example
date1,date2   double   TT as a 2-part Julian Date (Note 1)
@end example

Returned (see Note 2):

@example
eps0          double   epsilon_0
psia          double   psi_A
oma           double   omega_A
bpa           double   P_A
bqa           double   Q_A
pia           double   pi_A
bpia          double   Pi_A
epsa          double   obliquity epsilon_A
chia          double   chi_A
za            double   z_A
zetaa         double   zeta_A
thetaa        double   theta_A
pa            double   p_A
gam           double   F-W angle gamma_J2000
phi           double   F-W angle phi_J2000
psi           double   F-W angle psi_J2000
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
This function returns the set of equinox based angles for the Capitaine
et al. ``P03'' precession theory, adopted by the IAU in 2006.  The
angles are set out in Table 1 of Hilton et al. (2006):

@example
eps0   epsilon_0   obliquity at J2000.0
psia   psi_A       luni-solar precession
oma    omega_A     inclination of equator wrt J2000.0 ecliptic
bpa    P_A         ecliptic pole x, J2000.0 ecliptic triad
bqa    Q_A         ecliptic pole -y, J2000.0 ecliptic triad
pia    pi_A        angle between moving and J2000.0 ecliptics
bpia   Pi_A        longitude of ascending node of the ecliptic
epsa   epsilon_A   obliquity of the ecliptic
chia   chi_A       planetary precession
za     z_A         equatorial precession: -3rd 323 Euler angle
zetaa  zeta_A      equatorial precession: -1st 323 Euler angle
thetaa theta_A     equatorial precession: 2nd 323 Euler angle
pa     p_A         general precession
gam    gamma_J2000 J2000.0 RA difference of ecliptic poles
phi    phi_J2000   J2000.0 codeclination of ecliptic pole
psi    psi_J2000   longitude difference of equator poles, J2000.0
@end example

The returned values are all radians.

@item
Hilton et al. (2006) Table 1 also contains angles that depend on models
distinct from the P03 precession theory itself, namely the IAU 2000A
frame bias and nutation.  The quoted polynomials are used in other SOFA
functions:

@table @code
@item iauXy06
Contains the polynomial parts of the X and Y series.

@item iauS06
Contains the polynomial part of the s+XY/2 series.

@item iauPfw06
Implements the series for the Fukushima--Williams angles that are with
respect to the GCRS pole (i.e. the variants that include frame bias).
@end table

@item
The IAU resolution stipulated that the choice of parameterization was
left to the user, and so an IAU compliant precession implementation can
be constructed using various combinations of the angles returned by the
present function.

@item
The parameterization used by SOFA is the version of the Fukushima-
Williams angles that refers directly to the GCRS pole.  These angles may
be calculated by calling the function iauPfw06.  SOFA also supports the
direct computation of the CIP GCRS X,Y by series, available by calling
iauXy06.

@item
The agreement between the different parameterizations is at the 1
microarcsecond level in the present era.

@item
When constructing a precession formulation that refers to the GCRS pole
rather than the dynamical pole, it may (depending on the choice of
angles) be necessary to introduce the frame bias explicitly.

@item
It is permissible to re-use the same variable in the returned arguments.
The quantities are stored in the stated order.
@end enumerate

Called:

@table @code
@item iauObl06
Mean obliquity, IAU 2006.
@end table

Reference:

@itemize
@item
Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPb06 (double @vari{date}, double @varii{date}, double * @var{bzeta}, double * @var{bz}, double * @var{btheta})
This function forms three Euler angles which implement general
precession from epoch J2000.0, using the IAU 2006 model.  Frame bias
(the offset between ICRS and mean J2000.0) is included.

Status: support function.

Given:

@example
date1,date2  double   TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
bzeta        double   1st rotation: radians cw around z
bz           double   3rd rotation: radians cw around z
btheta       double   2nd rotation: radians ccw around y
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The traditional accumulated precession angles zeta_A, z_A, theta_A
cannot be obtained in the usual way, namely through polynomial
expressions, because of the frame bias.  The latter means that two of
the angles undergo rapid changes near this date.  They are instead the
results of decomposing the precession--bias matrix obtained by using the
Fukushima--Williams method, which does not suffer from the problem.  The
decomposition returns values which can be used in the conventional
formulation and which include frame bias.

@item
The three angles are returned in the conventional order, which is not
the same as the order of the corresponding Euler rotations.  The
precession--bias matrix is:

@example
R_3(-z) x R_2(+theta) x R_3(-zeta).
@end example

@item
Should zeta_A, z_A, theta_A angles be required that do not contain frame
bias, they are available by calling the @sofa{} function iauP06e.
@end enumerate

Called:

@table @code
@item iauPmat06
PB matrix, IAU 2006.

@item iauRz
Rotate around @math{Z}-axis.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPfw06 (double @vari{date}, double @varii{date}, double * @var{gamb}, double * @var{phib}, double * @var{psib}, double * @var{epsa})
Precession angles, IAU 2006 (Fukushima--Williams 4-angle formulation).

Status: canonical model.

Given:

@example
date1,date2  double   TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
gamb         double   F-W angle gamma_bar (radians)
phib         double   F-W angle phi_bar (radians)
psib         double   F-W angle psi_bar (radians)
epsa         double   F-W angle epsilon_A (radians)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
Naming the following points:

@example
e = J2000.0 ecliptic pole,
p = GCRS pole,
E = mean ecliptic pole of date,
P = mean pole of date,
@end example

@noindent
the four Fukushima--Williams angles are as follows:

@example
gamb = gamma_bar = epE
phib = phi_bar = pE
psib = psi_bar = pEP
epsa = epsilon_A = EP
@end example

@item
The matrix representing the combined effects of frame bias and
precession is:

@example
PxB = R_1(-epsa).R_3(-psib).R_1(phib).R_3(gamb)
@end example

@item
The matrix representing the combined effects of frame bias, precession
and nutation is simply:

@example
NxPxB = R_1(-epsa-dE).R_3(-psib-dP).R_1(phib).R_3(gamb)
@end example

@noindent
where dP and dE are the nutation components with respect to the ecliptic
of date.
@end enumerate

Called:

@table @code
@item iauObl06
Mean obliquity, IAU 2006.
@end table

Reference:

@itemize
@item
Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPmat00 (double @vari{date}, double @varii{date}, double @var{rbp}[3][3])
Precession matrix (including frame bias) from GCRS to a specified date,
IAU 2000 model.

Status: support function.

Given:

@example
date1,date2  double          TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rbp          double[3][3]    bias-precession matrix (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix operates in the sense @code{V(date) = rbp * V(GCRS)}, where
the @code{p}-vector @code{V(GCRS)} is with respect to the Geocentric
Celestial Reference System (IAU, 2000) and the @code{p}-vector
@code{V(date)} is with respect to the mean equatorial triad of the given
date.
@end enumerate

Called:

@table @code
@item iauBp00
Frame bias and precession matrices, IAU 2000.
@end table

Reference:

@itemize
@item
IAU: Trans. International Astronomical Union, Vol. XXIVB; Proc.  24th
General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.  (2000).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPmat06 (double @vari{date}, double @varii{date}, double @var{rbp}[3][3])
Precession matrix (including frame bias) from GCRS to a specified date,
IAU 2006 model.

Status: support function.

Given:

@example
date1,date2  double          TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rbp          double[3][3]    bias-precession matrix (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix operates in the sense @code{V(date) = rbp * V(GCRS)}, where
the @code{p}-vector @code{V(GCRS)} is with respect to the Geocentric
Celestial Reference System (IAU, 2000) and the @code{p}-vector V(date)
is with respect to the mean equatorial triad of the given date.
@end enumerate

Called:

@table @code
@item iauPfw06
Bias-precession F-W angles, IAU 2006.

@item iauFw2m
F-W angles to @code{r}-matrix.
@end table

References:

@itemize
@item
Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855

@item
Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPmat76 (double @vari{date}, double @varii{date}, double @var{rmatp}[3][3])
Precession matrix from J2000.0 to a specified date, IAU 1976 model.

Status: support function.

Given:

@example
date1,date2 double       ending date, TT (Note 1)
@end example

Returned:

@example
rmatp       double[3][3] precession matrix, J2000.0 -> @code{@vari{date} + @varii{date}}
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix operates in the sense @code{V(date) = RMATP * V(J2000)},
where the @code{p}-vector @code{V(J2000)} is with respect to the mean
equatorial triad of epoch J2000.0 and the @code{p}-vector @code{V(date)}
is with respect to the mean equatorial triad of the given date.

@item
Though the matrix method itself is rigorous, the precession angles are
expressed through canonical polynomials which are valid only for a
limited time span.  In addition, the IAU 1976 precession rate is known
to be imperfect.  The absolute accuracy of the present formulation is
better than 0.1 arcsec from 1960AD to 2040AD, better than 1 arcsec from
1640AD to 2360AD, and remains below 3 arcsec for the whole of the period
500BC to 3000AD.  The errors exceed 10 arcsec outside the range 1200BC
to 3900AD, exceed 100 arcsec outside 4200BC to 5600AD and exceed 1000
arcsec outside 6800BC to 8200AD.
@end enumerate

Called:

@table @code
@item iauPrec76
Accumulated precession angles, IAU 1976.

@item iauIr
Initialize @code{r}-matrix to identity.

@item iauRz
Rotate around @math{Z}-axis.

@item iauRy
Rotate around @math{Y}-axis.

@item iauCr
Copy @code{r}-matrix.
@end table

References:

@itemize
@item
Lieske, J.H., 1979, Astron.Astrophys. 73, 282.

@item
Equations (6) & (7), p283.

@item
Kaplan,G.H., 1981. USNO circular no. 163, pA2.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPn00 (double @vari{date}, double @varii{date}, double @var{dpsi}, double @var{deps}, double * @var{epsa}, double @var{rb}[3][3], double @var{rp}[3][3], double @var{rbp}[3][3], double @var{rn}[3][3], double @var{rbpn}[3][3])
Precession--nutation, IAU 2000 model: a multi--purpose function,
supporting classical (equinox--based) use directly and CIO--based use
indirectly.

Status: support function.

Given:

@example
date1,date2  double          TT as a 2-part Julian Date (Note 1)
dpsi,deps    double          nutation (Note 2)
@end example

Returned:

@example
epsa         double          mean obliquity (Note 3)
rb           double[3][3]    frame bias matrix (Note 4)
rp           double[3][3]    precession matrix (Note 5)
rbp          double[3][3]    bias-precession matrix (Note 6)
rn           double[3][3]    nutation matrix (Note 7)
rbpn         double[3][3]    GCRS-to-true matrix (Note 8)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The caller is responsible for providing the nutation components; they
are in longitude and obliquity, in radians and are with respect to the
equinox and ecliptic of date.  For high--accuracy applications, free
core nutation should be included as well as any other relevant
corrections to the position of the CIP.

@item
The returned mean obliquity is consistent with the IAU 2000
precession--nutation models.

@item
The matrix @var{rb} transforms vectors from GCRS to J2000.0 mean equator
and equinox by applying frame bias.

@item
The matrix @var{rp} transforms vectors from J2000.0 mean equator and
equinox to mean equator and equinox of date by applying precession.

@item
The matrix @var{rbp} transforms vectors from GCRS to mean equator and
equinox of date by applying frame bias then precession.  It is the
product @code{@var{rp} * @var{rb}}.

@item
The matrix @var{rn} transforms vectors from mean equator and equinox of
date to true equator and equinox of date by applying the nutation
(luni--solar + planetary).

@item
The matrix rbpn transforms vectors from GCRS to true equator and equinox
of date.  It is the product @code{@var{rn} * @var{rbp}}, applying frame
bias, precession and nutation in that order.

@item
It is permissible to re-use the same array in the returned arguments.
The arrays are filled in the order given.
@end enumerate

Called:

@table @code
@item iauPr00
IAU 2000 precession adjustments.

@item iauObl80
Mean obliquity, IAU 1980.

@item iauBp00
Frame bias and precession matrices, IAU 2000.

@item iauCr
Copy @code{r}-matrix.
@item iauNumat
Form nutation matrix.

@item iauRxr
Product of two @code{r}-matrices.
@end table

Reference:

@itemize
@item
Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., ``Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession--nutation model'',
Astron.Astrophys. 400, 1145-1154 (2003).

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed ``celestial
intermediate origin'' (CIO) by IAU 2006 Resolution 2.
@end quotation
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPn00a (double @vari{date}, double @varii{date}, double * @var{dpsi}, double * @var{deps}, double * @var{epsa}, double @var{rb}[3][3], double @var{rp}[3][3], double @var{rbp}[3][3], double @var{rn}[3][3], double @var{rbpn}[3][3])
Precession--nutation, IAU 2000A model: a multi--purpose function,
supporting classical (equinox--based) use directly and CIO--based use
indirectly.

Status: support function.

Given:

@example
date1,date2  double          TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
dpsi,deps    double          nutation (Note 2)
epsa         double          mean obliquity (Note 3)
rb           double[3][3]    frame bias matrix (Note 4)
rp           double[3][3]    precession matrix (Note 5)
rbp          double[3][3]    bias-precession matrix (Note 6)
rn           double[3][3]    nutation matrix (Note 7)
rbpn         double[3][3]    GCRS-to-true matrix (Notes 8,9)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The nutation components (luni--solar + planetary, IAU 2000A) in
longitude and obliquity are in radians and with respect to the equinox
and ecliptic of date.  Free core nutation is omitted; for the utmost
accuracy, use the @code{iauPn00} function, where the nutation components
are caller--specified.  For faster but slightly less accurate results,
use the @code{iauPn00b} function.

@item
The mean obliquity is consistent with the IAU 2000 precession.

@item
The matrix rb transforms vectors from GCRS to J2000.0 mean equator and
equinox by applying frame bias.

@item
The matrix @var{rp} transforms vectors from J2000.0 mean equator and
equinox to mean equator and equinox of date by applying precession.

@item
The matrix rbp transforms vectors from GCRS to mean equator and equinox
of date by applying frame bias then precession.  It is the product
@code{@var{rp} * @var{rb}}.

@item
The matrix @var{rn} transforms vectors from mean equator and equinox of
date to true equator and equinox of date by applying the nutation
(luni--solar + planetary).

@item
The matrix rbpn transforms vectors from GCRS to true equator and equinox
of date.  It is the product @code{@var{rn} * @var{rbp}}, applying frame
bias, precession and nutation in that order.

@item
The @math{X}, @math{Y}, @math{Z} coordinates of the IAU 2000B Celestial
Intermediate Pole are elements @math{(3,1-3)} of the matrix @var{rbpn}.

@item
It is permissible to re-use the same array in the returned arguments.
The arrays are filled in the order given.
@end enumerate

Called:

@table @code
@item iauNut00a
Nutation, IAU 2000A.

@item iauPn00
Bias/precession/nutation results, IAU 2000.
@end table

Reference:

@itemize
@item
Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., ``Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession--nutation model'',
Astron.Astrophys. 400, 1145-1154 (2003).

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed ``celestial
intermediate origin'' (CIO) by IAU 2006 Resolution 2.
@end quotation
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPn00b (double @vari{date}, double @varii{date}, double * @var{dpsi}, double * @var{deps}, double * @var{epsa}, double @var{rb}[3][3], double @var{rp}[3][3], double @var{rbp}[3][3], double @var{rn}[3][3], double @var{rbpn}[3][3])
Precession--nutation, IAU 2000B model: a multi--purpose function,
supporting classical (equinox--based) use directly and CIO--based use
indirectly.

Status: support function.

Given:

@example
date1,date2  double          TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
dpsi,deps    double          nutation (Note 2)
epsa         double          mean obliquity (Note 3)
rb           double[3][3]    frame bias matrix (Note 4)
rp           double[3][3]    precession matrix (Note 5)
rbp          double[3][3]    bias-precession matrix (Note 6)
rn           double[3][3]    nutation matrix (Note 7)
rbpn         double[3][3]    GCRS-to-true matrix (Notes 8,9)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The nutation components (luni--solar + planetary, IAU 2000B) in
longitude and obliquity are in radians and with respect to the equinox
and ecliptic of date.  For more accurate results, but at the cost of
increased computation, use the @code{iauPn00a} function.  For the utmost
accuracy, use the @code{iauPn00} function, where the nutation components
are caller--specified.

@item
The mean obliquity is consistent with the IAU 2000 precession.

@item
The matrix @var{rb} transforms vectors from GCRS to J2000.0 mean equator
and equinox by applying frame bias.

@item
The matrix @var{rp} transforms vectors from J2000.0 mean equator and
equinox to mean equator and equinox of date by applying precession.

@item
The matrix @var{rbp} transforms vectors from GCRS to mean equator and
equinox of date by applying frame bias then precession.  It is the
product @code{@var{rp} * @var{rb}}.

@item
The matrix @var{rn} transforms vectors from mean equator and equinox of
date to true equator and equinox of date by applying the nutation
(luni--solar + planetary).

@item
The matrix @var{rbpn} transforms vectors from GCRS to true equator and
equinox of date.  It is the product @code{@var{rn} * @var{rbp}},
applying frame bias, precession and nutation in that order.

@item
The @math{X}, @math{Y}, @math{Z} coordinates of the IAU 2000B Celestial
Intermediate Pole are elements @math{(3,1-3)} of the matrix rbpn.

@item
It is permissible to re-use the same array in the returned arguments.
The arrays are filled in the stated order.
@end enumerate

Called:

@table @code
@item iauNut00b
Nutation, IAU 2000B.

@item iauPn00
Bias/precession/nutation results, IAU 2000.
@end table

Reference:

@itemize
@item
Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., ``Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession--nutation model'',
Astron.Astrophys. 400, 1145-1154 (2003).

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed ``celestial
intermediate origin'' (CIO) by IAU 2006 Resolution 2.
@end quotation
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPn06 (double @vari{date}, double @varii{date}, double @var{dpsi}, double @var{deps}, double * @var{epsa}, double @var{rb}[3][3], double @var{rp}[3][3], double @var{rbp}[3][3], double @var{rn}[3][3], double @var{rbpn}[3][3])
Precession--nutation, IAU 2006 model: a multi--purpose function,
supporting classical (equinox--based) use directly and CIO--based use
indirectly.

Status: support function.

Given:

@example
date1,date2  double          TT as a 2-part Julian Date (Note 1)
dpsi,deps    double          nutation (Note 2)
@end example

Returned:

@example
epsa         double          mean obliquity (Note 3)
rb           double[3][3]    frame bias matrix (Note 4)
rp           double[3][3]    precession matrix (Note 5)
rbp          double[3][3]    bias-precession matrix (Note 6)
rn           double[3][3]    nutation matrix (Note 7)
rbpn         double[3][3]    GCRS-to-true matrix (Note 8)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The caller is responsible for providing the nutation components; they
are in longitude and obliquity, in radians and are with respect to the
equinox and ecliptic of date.  For high--accuracy applications, free
core nutation should be included as well as any other relevant
corrections to the position of the CIP.

@item
The returned mean obliquity is consistent with the IAU 2006 precession.

@item
The matrix @var{rb} transforms vectors from GCRS to J2000.0 mean equator
and equinox by applying frame bias.

@item
The matrix @var{rp} transforms vectors from J2000.0 mean equator and
equinox to mean equator and equinox of date by applying precession.

@item
The matrix @var{rbp} transforms vectors from GCRS to mean equator and
equinox of date by applying frame bias then precession.  It is the
product @code{@var{rp} * @var{rb}}.

@item
The matrix @var{rn} transforms vectors from mean equator and equinox of
date to true equator and equinox of date by applying the nutation
(luni--solar + planetary).

@item
The matrix @var{rbpn} transforms vectors from GCRS to true equator and
equinox of date.  It is the product @code{@var{rn} * @var{rbp}},
applying frame bias, precession and nutation in that order.

@item
The @math{X}, @math{Y}, @math{Z} coordinates of the IAU 2000B Celestial
Intermediate Pole are elements @math{(3,1-3)} of the matrix @var{rbpn}.

@item
It is permissible to re-use the same array in the returned arguments.
The arrays are filled in the stated order.
@end enumerate

Called:

@table @code
@item iauPfw06
Bias-precession F-W angles, IAU 2006.

@item iauFw2m
F-W angles to @code{r}-matrix.

@item iauCr
Copy @code{r}-matrix.

@item iauTr
Transpose @code{r}-matrix.

@item iauRxr
Product of two @code{r}-matrices.
@end table

References:

@itemize
@item
Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855

@item
Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPn06a (double @vari{date}, double @varii{date}, double * @var{dpsi}, double * @var{deps}, double * @var{epsa}, double @var{rb}[3][3], double @var{rp}[3][3], double @var{rbp}[3][3], double @var{rn}[3][3], double @var{rbpn}[3][3])
Precession--nutation, IAU 2006/2000A models: a multi--purpose function,
supporting classical (equinox--based) use directly and CIO--based use
indirectly.

Status: support function.

Given:

@example
date1,date2  double          TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
dpsi,deps    double          nutation (Note 2)
epsa         double          mean obliquity (Note 3)
rb           double[3][3]    frame bias matrix (Note 4)
rp           double[3][3]    precession matrix (Note 5)
rbp          double[3][3]    bias-precession matrix (Note 6)
rn           double[3][3]    nutation matrix (Note 7)
rbpn         double[3][3]    GCRS-to-true matrix (Notes 8,9)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The nutation components (luni--solar + planetary, IAU 2000A) in
longitude and obliquity are in radians and with respect to the equinox
and ecliptic of date.  Free core nutation is omitted; for the utmost
accuracy, use the @code{iauPn06} function, where the nutation components
are caller--specified.

@item
The mean obliquity is consistent with the IAU 2006 precession.

@item
The matrix @var{rb} transforms vectors from GCRS to mean J2000.0 by
applying frame bias.

@item
The matrix @var{rp} transforms vectors from mean J2000.0 to mean of date
by applying precession.

@item
The matrix rbp transforms vectors from GCRS to mean of date by applying
frame bias then precession.  It is the product @code{@var{rp} *
@var{rb}}.

@item
The matrix @var{rn} transforms vectors from mean of date to true of date
by applying the nutation (luni--solar + planetary).

@item
The matrix rbpn transforms vectors from GCRS to true of date
(CIP/equinox).  It is the product @code{@var{rn} * @var{rbp}}, applying
frame bias, precession and nutation in that order.

@item
The @math{X}, @math{Y}, @math{Z} coordinates of the IAU 2006/2000A
Celestial Intermediate Pole are elements @math{(1,1-3)} of the matrix
@var{rbpn}.

@item
It is permissible to re-use the same array in the returned arguments.
The arrays are filled in the stated order.
@end enumerate

Called:

@table @code
@item iauNut06a
Nutation, IAU 2006/2000A.

@item iauPn06
Bias/precession/nutation results, IAU 2006.
@end table

Reference:

@itemize
@item
Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPnm00a (double @vari{date}, double @varii{date}, double @var{rbpn}[3][3])
Form the matrix of precession--nutation for a given date (including
frame bias), equinox--based, IAU 2000A model.

Status: support function.

Given:

@example
date1,date2  double     TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rbpn         double[3][3]    classical NPB matrix (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix operates in the sense @code{V(date) = rbpn * V(GCRS)}, where
the @code{p}-vector @code{V(date)} is with respect to the true
equatorial triad of date @code{@vari{date} + @varii{date}} and the
@code{p}-vector @code{V(GCRS)} is with respect to the Geocentric
Celestial Reference System (IAU, 2000).

@item
A faster, but slightly less accurate result (about @math{1} mas), can be
obtained by using instead the @code{iauPnm00b} function.
@end enumerate

Called:

@table @code
@item iauPn00a
Bias/precession/nutation, IAU 2000A.
@end table

Reference:

@itemize
@item
IAU: Trans. International Astronomical Union, Vol. XXIVB; Proc.  24th
General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.  (2000).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPnm00b (double @vari{date}, double @varii{date}, double @var{rbpn}[3][3])
Form the matrix of precession--nutation for a given date (including
frame bias), equinox--based, IAU 2000B model.

Status: support function.

Given:

@example
date1,date2 double       TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rbpn        double[3][3] bias-precession-nutation matrix (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix operates in the sense @code{V(date) = rbpn * V(GCRS)}, where
the @code{p}-vector @code{V(date)} is with respect to the true
equatorial triad of date @code{@vari{date} + @varii{date}} and the
@code{p}-vector V(GCRS) is with respect to the Geocentric Celestial
Reference System (IAU, 2000).

@item
The present function is faster, but slightly less accurate (about
@math{1} mas), than the @code{iauPnm00a} function.
@end enumerate

Called:

@table @code
@item iauPn00b
Bias/precession/nutation, IAU 2000B.
@end table

Reference:

@itemize
@item
IAU: Trans. International Astronomical Union, Vol. XXIVB; Proc.  24th
General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.  (2000).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPnm06a (double @vari{date}, double @varii{date}, double @var{rnpb}[3][3])
Form the matrix of precession--nutation for a given date (including
frame bias), IAU 2006 precession and IAU 2000A nutation models.

Status: support function.

Given:

@example
date1,date2 double       TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
rnpb        double[3][3] bias-precession-nutation matrix (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix operates in the sense @code{V(date) = rnpb * V(GCRS)}, where
the @code{p}-vector @code{V(date)} is with respect to the true
equatorial triad of date @code{@vari{date} + @varii{date}} and the
@code{p}-vector @code{V(GCRS)} is with respect to the Geocentric
Celestial Reference System (IAU, 2000).
@end enumerate

Called:

@table @code
@item iauPfw06
Bias-precession F-W angles, IAU 2006.

@item iauNut06a
Nutation, IAU 2006/2000A.

@item iauFw2m
F-W angles to @code{r}-matrix.
@end table

Reference:

@itemize
@item
Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPnm80 (double @vari{date}, double @varii{date}, double @var{rmatpn}[3][3])
Form the matrix of precession/nutation for a given date, IAU 1976
precession model, IAU 1980 nutation model.

Status: support function.

Given:

@example
date1,date2    double         TDB date (Note 1)
@end example

Returned:

@example
rmatpn         double[3][3]   combined precession/nutation matrix
@end example

Notes:

@enumerate
@item
The TDB date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TDB) = 2450123.7} could be expressed in any of these
ways, among others:

@example
  date1          date2

450123.7           0.0       (JD method)
451545.0       -1421.3       (J2000 method)
400000.5       50123.2       (MJD method)
450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The matrix operates in the sense @code{V(date) = rmatpn * V(J2000)},
where the @code{p}-vector V(date) is with respect to the true equatorial
triad of date @code{@vari{date} + @varii{date}} and the @code{p}-vector
@code{V(J2000)} is with respect to the mean equatorial triad of epoch
J2000.0.
@end enumerate

Called:

@table @code
@item iauPmat76
Precession matrix, IAU 1976.

@item iauNutm80
Nutation matrix, IAU 1980.

@item iauRxr
Product of two @code{r}-matrices.
@end table

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.3 (p145).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPom00 (double @var{xp}, double @var{yp}, double @var{sp}, double @var{rpom}[3][3])
Form the matrix of polar motion for a given date, IAU 2000.

Status: support function.

Given:

@example
xp,yp    double    coordinates of the pole (radians, Note 1)
sp       double    the TIO locator s' (radians, Note 2)
@end example

Returned:

@example
rpom     double[3][3]   polar-motion matrix (Note 3)
@end example

Notes:

@enumerate
@item
The arguments @var{xp} and @var{yp} are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to 0 and 90 deg west respectively.

@item
The argument @var{sp} is the TIO locator s', in radians, which positions
the Terrestrial Intermediate Origin on the equator.  It is obtained from
polar motion observations by numerical integration, and so is in essence
unpredictable.  However, it is dominated by a secular drift of about 47
microarcseconds per century, and so can be taken into account by using
s' = -47*t, where t is centuries since J2000.0.  The function
@code{iauSp00} implements this approximation.

@item
The matrix operates in the sense @code{V(TRS) = rpom * V(CIP)}, meaning
that it is the final rotation when computing the pointing direction to a
celestial source.
@end enumerate

Called:

@table @code
@item iauIr
Initialize @code{r}-matrix to identity.

@item iauRz
Rotate around @math{Z}-axis.

@item iauRy
Rotate around @math{Y}-axis.

@item iauRx
Rotate around @math{X}-axis.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPr00 (double @vari{date}, double @varii{date}, double * @var{dpsipr}, double * @var{depspr})
Precession--rate part of the IAU 2000 precession--nutation models (part
of MHB2000).

Status: canonical model.

Given:

@example
date1,date2    double  TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
dpsipr,depspr  double  precession corrections (Notes 2,3)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The precession adjustments are expressed as ``nutation components'',
corrections in longitude and obliquity with respect to the J2000.0
equinox and ecliptic.

@item
Although the precession adjustments are stated to be with respect to
Lieske et al. (1977), the MHB2000 model does not specify which set of
Euler angles are to be used and how the adjustments are to be applied.
The most literal and straightforward procedure is to adopt the
4-rotation epsilon_0, psi_A, omega_A, xi_A option, and to add dpsipr to
psi_A and depspr to both omega_A and eps_A.

@item
This is an implementation of one aspect of the IAU 2000A nutation model,
formally adopted by the IAU General Assembly in 2000, namely MHB2000
(Mathews et al. 2002).
@end enumerate

References:

@itemize
@item
Lieske, J.H., Lederle, T., Fricke, W. & Morando, B., ``Expressions for
the precession quantities based upon the IAU (1976) System of
Astronomical Constants'', Astron.Astrophys., 58, 1-16 (1977).

@item
Mathews, P.M., Herring, T.A., Buffet, B.A., ``Modeling of nutation and
precession New nutation series for nonrigid Earth and insights into the
Earth's interior'', J.Geophys.Res., 107, B4, 2002.  The MHB2000 code
itself was obtained on 9th September 2002 from:

@center @url{ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A}

@item
Wallace, P.T., ``Software for Implementing the IAU 2000 Resolutions'',
in IERS Workshop 5.1 (2002).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPrec76 (double @var{ep01}, double @var{ep02}, double @var{ep11}, double @var{ep12}, double * @var{zeta}, double * @var{z}, double * @var{theta})
IAU 1976 precession model.  This function forms the three Euler angles
which implement general precession between two epochs, using the IAU
1976 model (as for the FK5 catalog).

Status: canonical model.

Given:

@example
ep01,ep02   double    TDB starting epoch (Note 1)
ep11,ep12   double    TDB ending epoch (Note 1)
@end example

Returned:

@example
zeta        double    1st rotation: radians cw around z
z           double    3rd rotation: radians cw around z
theta       double    2nd rotation: radians ccw around y
@end example

Notes:

@enumerate
@item
The epochs @code{@var{ep01} + @var{ep02}} and @code{@var{ep11} +
@var{ep12}} are Julian Dates, apportioned in any convenient way between
the arguments @var{epn1} and @var{epn2}.  For example, @code{JD(TDB) =
2450123.7} could be expressed in any of these ways, among others:

@example
   epn1          epn2

450123.7           0.0       (JD method)
451545.0       -1421.3       (J2000 method)
400000.5       50123.2       (MJD method)
450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum optimum resolution.  The MJD
method and the date & time methods are both good compromises between
resolution and convenience.  The two epochs may be expressed using
different methods, but at the risk of losing some resolution.

@item
The accumulated precession angles @var{zeta}, @var{z}, @var{theta} are
expressed through canonical polynomials which are valid only for a
limited time span.  In addition, the IAU 1976 precession rate is known
to be imperfect.  The absolute accuracy of the present formulation is
better than 0.1 arcsec from 1960AD to 2040AD, better than 1 arcsec from
1640AD to 2360AD, and remains below 3 arcsec for the whole of the period
500BC to 3000AD.  The errors exceed 10 arcsec outside the range 1200BC
to 3900AD, exceed 100 arcsec outside 4200BC to 5600AD and exceed 1000
arcsec outside 6800BC to 8200AD.

@item
The three angles are returned in the conventional order, which is not
the same as the order of the corresponding Euler rotations.  The
precession matrix is:

@example
R_3(-z) * R_2(+theta) * R_3(-zeta)
@end example
@end enumerate

Reference:

@itemize
@item
Lieske, J.H., 1979, Astron.Astrophys. 73, 282, equations (6) & (7),
p283.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauS00 (double @vari{date}, double @varii{date}, double @var{x}, double @var{y})
The CIO locator @math{s}, positioning the Celestial Intermediate Origin
on the equator of the Celestial Intermediate Pole, given the CIP's
@math{X}, @math{Y} coordinates.  Compatible with IAU 2000A
precession--nutation.

Status: canonical model.

Given:

@example
date1,date2   double    TT as a 2-part Julian Date (Note 1)
x,y           double    CIP coordinates (Note 3)
@end example

Returned (function value):

@example
              double    the CIO locator @math{s} in radians (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The CIO locator @math{s} is the difference between the right ascensions
of the same point in two systems: the two systems are the GCRS and the
CIP, CIO, and the point is the ascending node of the CIP equator.  The
quantity @math{s} remains below @math{0.1} arcsecond throughout
1900-2100.

@item
The series used to compute @math{s} is in fact for @math{s + X Y/2},
where @math{X} and @math{Y} are the @math{x} and @math{y} components of
the CIP unit vector; this series is more compact than a direct series
for @math{s} would be.  This function requires @math{X}, @math{Y} to be
supplied by the caller, who is responsible for providing values that are
consistent with the supplied date.

@item
The model is consistent with the IAU 2000A precession--nutation.
@end enumerate

Called:

@table @code
@item iauFal03
Mean anomaly of the Moon.

@item iauFalp03
Mean anomaly of the Sun.

@item iauFaf03
Mean argument of the latitude of the Moon.

@item iauFad03
Mean elongation of the Moon from the Sun.

@item iauFaom03
Mean longitude of the Moon's ascending node.

@item iauFave03
Mean longitude of Venus.

@item iauFae03
Mean longitude of Earth.

@item iauFapa03
General accumulated precession in longitude.
@end table

References:

@itemize
@item
Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., ``Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession--nutation model'',
Astron.Astrophys. 400, 1145-1154 (2003).

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed ``celestial
intermediate origin'' (CIO) by IAU 2006 Resolution 2.
@end quotation

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauS00a (double @vari{date}, double @varii{date})
The CIO locator @math{s}, positioning the Celestial Intermediate Origin
on the equator of the Celestial Intermediate Pole, using the IAU 2000A
precession--nutation model.

Status: support function.

Given:

@example
date1,date2  double    TT as a 2-part Julian Date (Note 1)
@end example

Returned (function value):

@example
             double    the CIO locator @math{s} in radians (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The CIO locator @math{s} is the difference between the right ascensions
of the same point in two systems.  The two systems are the GCRS and the
CIP, CIO, and the point is the ascending node of the CIP equator.  The
CIO locator @math{s} remains a small fraction of @math{1} arcsecond
throughout 1900-2100.

@item
The series used to compute @math{s} is in fact for @math{s + X Y/2},
where @math{X} and @math{Y} are the @math{x} and @math{y} components of
the CIP unit vector; this series is more compact than a direct series
for @math{s} would be.  The present function uses the full IAU 2000A
nutation model when predicting the CIP position.  Faster results, with
no significant loss of accuracy, can be obtained via the function
@code{iauS00b}, which uses instead the IAU 2000B truncated model.
@end enumerate

Called:

@table @code
@item iauPnm00a
Classical NPB matrix, IAU 2000A.

@item iauBnp2xy
Extract CIP @math{X}, @math{Y} from the BPN matrix.

@item iauS00
The CIO locator @math{s}, given @math{X}, @math{Y}, IAU 2000A.
@end table

References:

@itemize
@item
Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., ``Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession--nutation model'',
Astron.Astrophys. 400, 1145-1154 (2003).

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed ``celestial
intermediate origin'' (CIO) by IAU 2006 Resolution 2.
@end quotation

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauS00b (double @vari{date}, double @varii{date})
The CIO locator @math{s}, positioning the Celestial Intermediate Origin
on the equator of the Celestial Intermediate Pole, using the IAU 2000B
precession--nutation model.

Status: support function.

Given:

@example
date1,date2  double    TT as a 2-part Julian Date (Note 1)
@end example

Returned (function value):

@example
             double    the CIO locator @math{s} in radians (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The CIO locator @math{s} is the difference between the right ascensions
of the same point in two systems.  The two systems are the GCRS and the
CIP, CIO, and the point is the ascending node of the CIP equator.  The
CIO locator @math{s} remains a small fraction of @math{1} arcsecond
throughout 1900-2100.

@item
The series used to compute @math{s} is in fact for @math{s + X Y/2},
where @math{X} and @math{Y} are the @math{x} and @math{y} components of
the CIP unit vector; this series is more compact than a direct series
for @math{s} would be.  The present function uses the IAU 2000B
truncated nutation model when predicting the CIP position.  The function
iauS00a uses instead the full IAU 2000A model, but with no significant
increase in accuracy and at some cost in speed.
@end enumerate

Called:

@table @code
@item iauPnm00b
Classical NPB matrix, IAU 2000B.

@item iauBnp2xy
Extract CIP @math{X}, @math{Y} from the BPN matrix.

@item iauS00
The CIO locator @math{s}, given @math{X}, @math{Y}, IAU 2000A.
@end table

References:

@itemize
@item
Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., ``Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession--nutation model'',
Astron.Astrophys. 400, 1145-1154 (2003).

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed ``celestial
intermediate origin'' (CIO) by IAU 2006 Resolution 2.
@end quotation

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauS06 (double @vari{date}, double @varii{date}, double @var{x}, double @var{y})
The CIO locator @math{s}, positioning the Celestial Intermediate Origin
on the equator of the Celestial Intermediate Pole, given the CIP's
@math{X}, @math{Y} coordinates.  Compatible with IAU 2006/2000A
precession--nutation.

Status: canonical model.

Given:

@example
date1,date2   double    TT as a 2-part Julian Date (Note 1)
x,y           double    CIP coordinates (Note 3)
@end example

Returned (function value):

@example
              double    the CIO locator @math{s} in radians (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The CIO locator @math{s} is the difference between the right ascensions
of the same point in two systems: the two systems are the GCRS and the
CIP, CIO, and the point is the ascending node of the CIP equator.  The
quantity @math{s} remains below @math{0.1} arcsecond throughout
1900-2100.

@item
The series used to compute @math{s} is in fact for @math{s + X Y/2},
where @math{X} and @math{Y} are the @math{x} and @math{y} components of
the CIP unit vector; this series is more compact than a direct series
for @math{s} would be.  This function requires @math{X}, @math{Y} to be
supplied by the caller, who is responsible for providing values that are
consistent with the supplied date.

@item
The model is consistent with the ``P03'' precession (Capitaine et
al. 2003), adopted by IAU 2006 Resolution 1, 2006, and the IAU 2000A
nutation (with P03 adjustments).
@end enumerate

Called:

@table @code
@item iauFal03
Mean anomaly of the Moon.

@item iauFalp03
Mean anomaly of the Sun.

@item iauFaf03
Mean argument of the latitude of the Moon.

@item iauFad03
Mean elongation of the Moon from the Sun.

@item iauFaom03
Mean longitude of the Moon's ascending node.

@item iauFave03
Mean longitude of Venus.

@item iauFae03
Mean longitude of Earth.

@item iauFapa03
General accumulated precession in longitude.
@end table

References:

@itemize
@item
Capitaine, N., Wallace, P.T. & Chapront, J., 2003, Astron.
Astrophys. 432, 355.

@item
McCarthy, D.D., Petit, G. (eds.) 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauS06a (double @vari{date}, double @varii{date})
The CIO locator @math{s}, positioning the Celestial Intermediate Origin
on the equator of the Celestial Intermediate Pole, using the IAU 2006
precession and IAU 2000A nutation models.

Status: support function.

Given:

@example
date1,date2  double    TT as a 2-part Julian Date (Note 1)
@end example

Returned (function value):

@example
             double    the CIO locator @math{s} in radians (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The CIO locator @math{s} is the difference between the right ascensions
of the same point in two systems.  The two systems are the GCRS and the
CIP, CIO, and the point is the ascending node of the CIP equator.  The
CIO locator @math{s} remains a small fraction of @math{1} arcsecond
throughout 1900-2100.

@item
The series used to compute @math{s} is in fact for @math{s + X Y/2},
where @math{X} and @math{Y} are the @math{x} and @math{y} components of
the CIP unit vector; this series is more compact than a direct series
for @math{s} would be.  The present function uses the full IAU 2000A
nutation model when predicting the CIP position.
@end enumerate

Called:

@table @code
@item iauPnm06a
Classical NPB matrix, IAU 2006/2000A.

@item iauBpn2xy
Extract CIP X,Y coordinates from NPB matrix.

@item iauS06
The CIO locator @math{s}, given X,Y, IAU 2006.
@end table

References:

@itemize
@item
Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., ``Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession--nutation model'',
Astron.Astrophys. 400, 1145-1154 (2003).

@quotation
n.b. The celestial ephemeris origin (CEO) was renamed ``celestial
intermediate origin'' (CIO) by IAU 2006 Resolution 2.
@end quotation

@item
Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855

@item
McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG.

@item
Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauSp00 (double @vari{date}, double @varii{date})
The TIO locator @math{s'}, positioning the Terrestrial Intermediate
Origin on the equator of the Celestial Intermediate Pole.

Status: canonical model.

Given:

@example
date1,date2  double    TT as a 2-part Julian Date (Note 1)
@end example

Returned (function value):

@example
             double    the TIO locator s' in radians (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The TIO locator @math{s'} is obtained from polar motion observations by
numerical integration, and so is in essence unpredictable.  However, it
is dominated by a secular drift of about @math{47} microarcseconds per
century, which is the approximation evaluated by the present function.
@end enumerate

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauXy06 (double @vari{date}, double @varii{date}, double * @var{x}, double * @var{y})
@math{X}, @math{Y} coordinates of celestial intermediate pole from
series based on IAU 2006 precession and IAU 2000A nutation.

Status: canonical model.

Given:

@example
date1,date2  double     TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
x,y          double     CIP X,Y coordinates (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The @math{X}, @math{Y} coordinates are those of the unit vector towards
the celestial intermediate pole.  They represent the combined effects of
frame bias, precession and nutation.

@item
The fundamental arguments used are as adopted in IERS Conventions (2003)
and are from Simon et al. (1994) and Souchay et al. (1999).

@item
This is an alternative to the angles--based method, via the @sofa{}
function @code{iauFw2xy} and as used in @code{iauXys06a} for example.
The two methods agree at the @math{1} microarcsecond level (at present),
a negligible amount compared with the intrinsic accuracy of the models.
However, it would be unwise to mix the two methods (angles--based and
series--based) in a single application.
@end enumerate

Called:

@table @code
@item iauFal03
Mean anomaly of the Moon.

@item iauFalp03
Mean anomaly of the Sun.

@item iauFaf03
Mean argument of the latitude of the Moon.

@item iauFad03
Mean elongation of the Moon from the Sun.

@item iauFaom03
Mean longitude of the Moon's ascending node.

@item iauFame03
Mean longitude of Mercury.

@item iauFave03
Mean longitude of Venus.

@item iauFae03
Mean longitude of Earth.

@item iauFama03
Mean longitude of Mars.

@item iauFaju03
Mean longitude of Jupiter.

@item iauFasa03
Mean longitude of Saturn.

@item iauFaur03
Mean longitude of Uranus.

@item iauFane03
Mean longitude of Neptune.

@item iauFapa03
General accumulated precession in longitude.
@end table

References:

@itemize
@item
Capitaine, N., Wallace, P.T. & Chapront, J., 2003, Astron.Astrophys.,
412, 567.

@item
Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855

@item
McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG.

@item
Simon, J.L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G. & Laskar, J., Astron.Astrophys., 1994, 282, 663

@item
Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M., 1999,
Astron.Astrophys.Supp.Ser. 135, 111

@item
Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauXys00a (double @vari{date}, double @varii{date}, double * @var{x}, double * @var{y}, double * @var{s})
For a given TT date, compute the @math{X}, @math{Y} coordinates of the
Celestial Intermediate Pole and the CIO locator @math{s}, using the IAU
2000A precession--nutation model.

Status: support function.

Given:

@example
date1,date2  double   TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
x,y          double   Celestial Intermediate Pole (Note 2)
s            double   the CIO locator @math{s} (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The Celestial Intermediate Pole coordinates are the @math{x}, @math{y}
components of the unit vector in the Geocentric Celestial Reference
System.

@item
The CIO locator @math{s} (in radians) positions the Celestial
Intermediate Origin on the equator of the CIP.

@item
A faster, but slightly less accurate result (about @math{1} mas for
@math{X}, @math{Y}), can be obtained by using instead the
@code{iauXys00b} function.
@end enumerate

Called:

@table @code
@item iauPnm00a
Classical NPB matrix, IAU 2000A.

@item iauBpn2xy
Extract CIP X,Y coordinates from NPB matrix.

@item iauS00
The CIO locator @math{s}, given X,Y, IAU 2000A.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauXys00b (double @vari{date}, double @varii{date}, double * @var{x}, double * @var{y}, double * @var{s})
For a given TT date, compute the @math{X}, @math{Y} coordinates of the
Celestial Intermediate Pole and the CIO locator @math{s}, using the IAU
2000B precession--nutation model.

Status: support function.

Given:

@example
date1,date2  double   TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
x,y          double   Celestial Intermediate Pole (Note 2)
s            double   the CIO locator @math{s} (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The Celestial Intermediate Pole coordinates are the @math{X}, @math{Y}
components of the unit vector in the Geocentric Celestial Reference
System.

@item
The CIO locator @math{s} (in radians) positions the Celestial
Intermediate Origin on the equator of the CIP.

@item
The present function is faster, but slightly less accurate (about
@math{1} mas in @math{X}, @math{Y}), than the @code{iauXys00a} function.
@end enumerate

Called:

@table @code
@item iauPnm00b
Classical NPB matrix, IAU 2000B.

@item iauBpn2xy
Extract CIP X,Y coordinates from NPB matrix.

@item iauS00
The CIO locator @math{s}, given X,Y, IAU 2000A.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauXys06a (double @vari{date}, double @varii{date}, double * @var{x}, double * @var{y}, double * @var{s})
For a given TT date, compute the X,Y coordinates of the Celestial
Intermediate Pole and the CIO locator @math{s}, using the IAU 2006
precession and IAU 2000A nutation models.

Status: support function.

Given:

@example
date1,date2  double  TT as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
x,y          double  Celestial Intermediate Pole (Note 2)
s            double  the CIO locator s (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and

@item
The Celestial Intermediate Pole coordinates are the @var{x}, @var{y}
components of the unit vector in the Geocentric Celestial Reference
System.

@item
The CIO locator @math{s} (in radians) positions the Celestial Intermediate
Origin on the equator of the CIP.

@item
Series--based solutions for generating @math{X} and @math{Y} are also
available: see Capitaine & Wallace (2006) and @code{iauXy06}.
@end enumerate

Called:

@table @code
@item iauPnm06a
Classical NPB matrix, IAU 2006/2000A.

@item iauBpn2xy
Extract CIP @math{X}, @math{Y} coordinates from NPB matrix.

@item iauS06
The CIO locator @math{s}, given @math{X}, @math{Y}, IAU 2006.
@end table

References:

@itemize
@item
Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855

@item
Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981.
@end itemize
@end deftypefun

@c page
@node api RotationAndTime
@subsection Rotation and time


@deftypefun double iauEe00 (double @vari{date}, double @varii{date}, double @var{epsa}, double @var{dpsi})
The equation of the equinoxes, compatible with IAU 2000 resolutions,
given the nutation in longitude and the mean obliquity.

Status: canonical model.

Given:

@example
date1,date2  double    TT as a 2-part Julian Date (Note 1)
epsa         double    mean obliquity (Note 2)
dpsi         double    nutation in longitude (Note 3)
@end example

Returned (function value):

@example
             double    equation of the equinoxes (Note 4)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The obliquity, in radians, is mean of date.

@item
The result, which is in radians, operates in the following sense:

@example
Greenwich apparent ST = GMST + equation of the equinoxes
@end example

@item
The result is compatible with the IAU 2000 resolutions.  For further
details, see IERS Conventions 2003 and Capitaine et al.  (2002).
@end enumerate

Called:

@table @code
@item iauEect00
Equation of the equinoxes complementary terms.
@end table

References:

@itemize
@item
Capitaine, N., Wallace, P.T. and McCarthy, D.D., ``Expressions to
implement the IAU 2000 definition of UT1'', Astronomy & Astrophysics,
406, 1135-1149 (2003)

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauEe00a (double @vari{date}, double @varii{date})
Equation of the equinoxes, compatible with IAU 2000 resolutions.

Status: support function.

Given:

@example
date1,date2  double    TT as a 2-part Julian Date (Note 1)
@end example

Returned (function value):

@example
             double    equation of the equinoxes (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The result, which is in radians, operates in the following sense:

@example
Greenwich apparent ST = GMST + equation of the equinoxes
@end example

@item
The result is compatible with the IAU 2000 resolutions.  For further
details, see IERS Conventions 2003 and Capitaine et al.  (2002).
@end enumerate

Called:

@table @code
@item iauPr00
IAU 2000 precession adjustments.

@item iauObl80
Mean obliquity, IAU 1980.

@item iauNut00a
Nutation, IAU 2000A.

@item iauEe00
Equation of the equinoxes, IAU 2000.
@end table

References:

@itemize
@item
Capitaine, N., Wallace, P.T. and McCarthy, D.D., ``Expressions to
implement the IAU 2000 definition of UT1'', Astronomy & Astrophysics,
406, 1135-1149 (2003).

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauEe00b (double @vari{date}, double @varii{date})
Equation of the equinoxes, compatible with IAU 2000 resolutions but
using the truncated nutation model IAU 2000B.

Status: support function.

Given:

@example
date1,date2  double    TT as a 2-part Julian Date (Note 1)
@end example

Returned (function value):

@example
             double    equation of the equinoxes (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The result, which is in radians, operates in the following sense:

@example
Greenwich apparent ST = GMST + equation of the equinoxes
@end example

@item
The result is compatible with the IAU 2000 resolutions except that
accuracy has been compromised for the sake of speed.  For further
details, see McCarthy & Luzum (2001), IERS Conventions 2003 and
Capitaine et al. (2003).
@end enumerate

Called:

@table @code
@item iauPr00
IAU 2000 precession adjustments.

@item iauObl80
Mean obliquity, IAU 1980.

@item iauNut00b
Nutation, IAU 2000B.

@item iauEe00
Equation of the equinoxes, IAU 2000.
@end table

References:

@itemize
@item
Capitaine, N., Wallace, P.T. and McCarthy, D.D., ``Expressions to
implement the IAU 2000 definition of UT1'', Astronomy & Astrophysics,
406, 1135-1149 (2003).

@item
McCarthy, D.D. & Luzum, B.J., ``An abridged model of the
precession--nutation of the celestial pole'', Celestial Mechanics &
Dynamical Astronomy, 85, 37-49 (2003).

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauEe06a (double @vari{date}, double @varii{date})
Equation of the equinoxes, compatible with IAU 2000 resolutions and IAU
2006/2000A precession--nutation.

Status: support function.

Given:

@example
date1,date2  double    TT as a 2-part Julian Date (Note 1)
@end example

Returned (function value):

@example
             double    equation of the equinoxes (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The result, which is in radians, operates in the following sense:

@example
Greenwich apparent ST = GMST + equation of the equinoxes
@end example
@end enumerate

Called:

@table @code
@item iauAnpm
Normalize angle into range +/- pi.

@item iauGst06a
Greenwich apparent sidereal time, IAU 2006/2000A.

@item iauGmst06
Greenwich mean sidereal time, IAU 2006.
@end table

Reference:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauEect00 (double @vari{date}, double @varii{date})
Equation of the equinoxes complementary terms, consistent with IAU 2000
resolutions.

Status: canonical model.

Given:

@example
date1,date2  double   TT as a 2-part Julian Date (Note 1)
@end example

Returned (function value):

@example
             double   complementary terms (Note 2)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The ``complementary terms'' are part of the equation of the equinoxes
(EE), classically the difference between apparent and mean Sidereal
Time:

@example
GAST = GMST + EE
@end example

@noindent
with:

@example
EE = dpsi * cos(eps)
@end example

@noindent
where @code{dpsi} is the nutation in longitude and eps is the obliquity
of date.  However, if the rotation of the Earth were constant in an
inertial frame the classical formulation would lead to apparent
irregularities in the UT1 timescale traceable to side--effects of
precession--nutation.  In order to eliminate these effects from UT1,
``complementary terms'' were introduced in 1994 (IAU, 1994) and took
effect from 1997 (Capitaine and Gontier, 1993):

@example
GAST = GMST + CT + EE
@end example

By convention, the complementary terms are included as part of the
equation of the equinoxes rather than as part of the mean Sidereal Time.
This slightly compromises the ``geometrical'' interpretation of mean
sidereal time but is otherwise inconsequential.

The present function computes @code{CT} in the above expression,
compatible with IAU 2000 resolutions (Capitaine et al., 2002, and IERS
Conventions 2003).
@end enumerate

Called:

@table @code
@item iauFal03
Mean anomaly of the Moon.

@item iauFalp03
Mean anomaly of the Sun.

@item iauFaf03
Mean argument of the latitude of the Moon.

@item iauFad03
Mean elongation of the Moon from the Sun.

@item iauFaom03
Mean longitude of the Moon's ascending node.

@item iauFave03
Mean longitude of Venus.

@item iauFae03
Mean longitude of Earth.

@item iauFapa03
General accumulated precession in longitude.
@end table

References:

@itemize
@item
Capitaine, N. & Gontier, A.-M., Astron. Astrophys., 275, 645-650 (1993).

@item
Capitaine, N., Wallace, P.T. and McCarthy, D.D., ``Expressions to
implement the IAU 2000 definition of UT1'', Astronomy & Astrophysics,
406, 1135-1149 (2003).

@item
IAU Resolution C7, Recommendation 3 (1994).

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauEqeq94 (double @vari{date}, double @varii{date})
Equation of the equinoxes, IAU 1994 model.

Status: canonical model.

Given:

@example
date1,date2   double     TDB date (Note 1)
@end example

Returned (function value):

@example
              double     equation of the equinoxes (Note 2)
@end example

Notes:

@enumerate
@item
The date @code{@vari{date} @varii{date}} is a Julian Date, apportioned
in any convenient way between the two arguments.  For example,
@code{JD(TT) = 2450123.7} could be expressed in any of these ways, among
others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The result, which is in radians, operates in the following sense:

@example
Greenwich apparent ST = GMST + equation of the equinoxes
@end example
@end enumerate

Called:

@table @code
@item iauNut80
Nutation, IAU 1980.

@item iauObl80
Mean obliquity, IAU 1980.
@end table

References:

@itemize
@item
IAU Resolution C7, Recommendation 3 (1994).

@item
Capitaine, N. & Gontier, A.-M., 1993, Astron. Astrophys., 275, 645-650.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauEra00 (double @var{dj1}, double @var{dj2})
Earth rotation angle (IAU 2000 model).

Status: canonical model.

Given:

@example
dj1,dj2   double    UT1 as a 2-part Julian Date (see note)
@end example

Returned (function value):

@example
double    Earth rotation angle (radians), range 0-2pi
@end example

Notes:

@enumerate
@item
The UT1 date @code{@var{dj1} + @var{dj2}} is a Julian Date, apportioned
in any convenient way between the arguments @var{dj1} and @var{dj2}.
For example, @code{JD(UT1) = 2450123.7} could be expressed in any of
these ways, among others:

@example
    dj1            dj2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  The date & time method is best matched to the algorithm
used: maximum precision is delivered when the @var{dj1} argument is for
0hrs UT1 on the day in question and the @var{dj2} argument lies in the
range 0 to 1, or vice versa.

@item
The algorithm is adapted from Expression 22 of Capitaine et al.  2000.
The time argument has been expressed in days directly, and, to retain
precision, integer contributions have been eliminated.  The same
formulation is given in IERS Conventions (2003), Chap. 5, Eq. 14.
@end enumerate

Called:

@table @code
@item iauAnp
Normalize angle into range 0 to 2pi.
@end table

References:

@itemize
@item
Capitaine N., Guinot B. and McCarthy D.D, 2000, Astron.  Astrophys.,
355, 398-405.

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauGmst00 (double @var{uta}, double @var{utb}, double @var{tta}, double @var{ttb})
Greenwich mean sidereal time (model consistent with IAU 2000
resolutions).

Status: canonical model.

Given:

@example
uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
tta,ttb    double    TT as a 2-part Julian Date (Notes 1,2)
@end example

Returned (function value):

@example
           double    Greenwich mean sidereal time (radians)
@end example

Notes:

@enumerate
@item
The UT1 and TT dates @code{@var{uta} + @var{utb}} and @code{@var{tta} +
@var{ttb}} respectively, are both Julian Dates, apportioned in any
convenient way between the argument pairs.  For example, @code{JD =
2450123.7} could be expressed in any of these ways, among others:

@example
   Part A         Part B

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable (in the
case of UT; the TT is not at all critical in this respect).  The J2000
and MJD methods are good compromises between resolution and convenience.
For UT, the date & time method is best matched to the algorithm that is
used by the Earth Rotation Angle function, called internally: maximum
precision is delivered when the uta argument is for 0hrs UT1 on the day
in question and the utb argument lies in the range 0 to 1, or vice
versa.

@item
Both UT1 and TT are required, UT1 to predict the Earth rotation and TT
to predict the effects of precession.  If UT1 is used for both purposes,
errors of order 100 microarcseconds result.

@item
This GMST is compatible with the IAU 2000 resolutions and must be used
only in conjunction with other IAU 2000 compatible components such as
precession-nutation and equation of the equinoxes.

@item
The result is returned in the range 0 to 2pi.

@item
The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003.
@end enumerate

Called:

@table @code
@item iauEra00
Earth rotation angle, IAU 2000.

@item iauAnp
Normalize angle into range 0 to 2pi.
@end table

References:

@itemize
@item
Capitaine, N., Wallace, P.T. and McCarthy, D.D., ``Expressions to
implement the IAU 2000 definition of UT1'', Astronomy & Astrophysics,
406, 1135-1149 (2003)

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauGmst06 (double @var{uta}, double @var{utb}, double @var{tta}, double @var{ttb})
Greenwich mean sidereal time (consistent with IAU 2006 precession).

Status: canonical model.

Given:

@example
uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
tta,ttb    double    TT as a 2-part Julian Date (Notes 1,2)
@end example

Returned (function value):

@example
           double    Greenwich mean sidereal time (radians)
@end example

Notes:

@enumerate
@item
The UT1 and TT dates @code{@var{uta} + @var{utb}} and @code{@var{tta} +
@var{ttb}} respectively, are both Julian Dates, apportioned in any
convenient way between the argument pairs.  For example, @code{JD =
2450123.7} could be expressed in any of these ways, among others:

@example
   Part A        Part B

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable (in the
case of UT; the TT is not at all critical in this respect).  The J2000
and MJD methods are good compromises between resolution and convenience.
For UT, the date & time method is best matched to the algorithm that is
used by the Earth rotation angle function, called internally: maximum
precision is delivered when the @var{uta} argument is for 0hrs UT1 on
the day in question and the @var{utb} argument lies in the range
@math{0} to @math{1}, or vice versa.

@item
Both UT1 and TT are required, UT1 to predict the Earth rotation and TT
to predict the effects of precession.  If UT1 is used for both purposes,
errors of order 100 microarcseconds result.

@item
This GMST is compatible with the IAU 2006 precession and must not be
used with other precession models.

@item
The result is returned in the range 0 to 2pi.
@end enumerate

Called:

@table @code
@item iauEra00
Earth rotation angle, IAU 2000.

@item iauAnp
Normalize angle into range 0 to 2pi.
@end table

Reference:

@itemize
@item
Capitaine, N., Wallace, P.T. & Chapront, J., 2005,
Astron.Astrophys. 432, 355.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauGmst82 (double @var{dj1}, double @var{dj2})
Universal Time to Greenwich mean sidereal time (IAU 1982 model).

Status: canonical model.

Given:

@example
dj1,dj2    double    UT1 Julian Date (see note)
@end example

Returned (function value):

@example
           double    Greenwich mean sidereal time (radians)
@end example

Notes:

@enumerate
@item
The UT1 date @code{@var{dj1} + @var{dj2}} is a Julian Date, apportioned
in any convenient way between the arguments @var{dj1} and @var{dj2}.
For example, @code{JD(UT1) = 2450123.7} could be expressed in any of
these ways, among others:

@example
    dj1            dj2

2450123.7D0        0D0        (JD method)
 2451545D0      -1421.3D0     (J2000 method)
2400000.5D0     50123.2D0     (MJD method)
2450123.5D0       0.2D0       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  The date & time method is best matched to the algorithm
used: maximum accuracy (or, at least, minimum noise) is delivered when
the @var{dj1} argument is for 0hrs UT1 on the day in question and the
@var{dj2} argument lies in the range 0 to 1, or vice versa.

@item
The algorithm is based on the IAU 1982 expression.  This is always
described as giving the GMST at 0 hours UT1.  In fact, it gives the
difference between the GMST and the UT, the steady 4--minutes--per--day
drawing--ahead of ST with respect to UT.  When whole days are ignored,
the expression happens to equal the GMST at 0 hours UT1 each day.

@item
In this function, the entire UT1 (the sum of the two arguments @var{dj1}
and @var{dj2}) is used directly as the argument for the standard
formula, the constant term of which is adjusted by 12 hours to take
account of the noon phasing of Julian Date.  The UT1 is then added, but
omitting whole days to conserve accuracy.
@end enumerate

Called:

@table @code
@item iauAnp
Normalize angle into range 0 to 2pi.
@end table

References:

@itemize
@item
Transactions of the International Astronomical Union, XVIII B, 67
(1983).

@item
Aoki et al., Astron. Astrophys. 105, 359-361 (1982).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauGst00a (double @var{uta}, double @var{utb}, double @var{tta}, double @var{ttb})
Greenwich apparent sidereal time (consistent with IAU 2000 resolutions).

Status: canonical model.

Given:

@example
uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
tta,ttb    double    TT as a 2-part Julian Date (Notes 1,2)
@end example

Returned (function value):

@example
           double    Greenwich apparent sidereal time (radians)
@end example

Notes:

@enumerate
@item
The UT1 and TT dates @code{@var{uta} + @var{utb}} and @code{@var{tta} +
@var{ttb}} respectively, are both Julian Dates, apportioned in any
convenient way between the argument pairs.  For example, @code{JD =
2450123.7} could be expressed in any of these ways, among others:

@example
   Part A        Part B

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable (in the
case of UT; the TT is not at all critical in this respect).  The J2000
and MJD methods are good compromises between resolution and convenience.
For UT, the date & time method is best matched to the algorithm that is
used by the Earth Rotation Angle function, called internally: maximum
precision is delivered when the uta argument is for 0hrs UT1 on the day
in question and the @var{utb} argument lies in the range 0 to 1, or vice
versa.

@item
Both UT1 and TT are required, UT1 to predict the Earth rotation and TT
to predict the effects of precession--nutation.  If UT1 is used for both
purposes, errors of order 100 microarcseconds result.

@item
This GAST is compatible with the IAU 2000 resolutions and must be used
only in conjunction with other IAU 2000 compatible components such as
precession--nutation.

@item
The result is returned in the range 0 to 2pi.

@item
The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003.
@end enumerate

Called:

@table @code
@item iauGmst00
Greenwich mean sidereal time, IAU 2000.

@item iauEe00a
Equation of the equinoxes, IAU 2000A.

@item iauAnp
Normalize angle into range 0 to 2pi.
@end table

References:

@itemize
@item
Capitaine, N., Wallace, P.T. and McCarthy, D.D., ``Expressions to
implement the IAU 2000 definition of UT1'', Astronomy & Astrophysics,
406, 1135-1149 (2003)

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauGst00b (double @var{uta}, double @var{utb})
Greenwich apparent sidereal time (consistent with IAU 2000
resolutions but using the truncated nutation model IAU 2000B).

Status: support function.

Given:

@example
uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
@end example

Returned (function value):

@example
           double    Greenwich apparent sidereal time (radians)
@end example

Notes:

@enumerate
@item
The UT1 date @code{@var{uta} + @var{utb}} is a Julian Date, apportioned
in any convenient way between the argument pair.  For example, @code{JD
= 2450123f.7} could be expressed in any of these ways, among others:

@example
    uta            utb

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  For UT, the date & time method is best matched to the
algorithm that is used by the Earth Rotation Angle function, called
internally: maximum precision is delivered when the @var{uta} argument
is for 0hrs UT1 on the day in question and the @var{utb} argument lies
in the range 0 to 1, or vice versa.

@item
The result is compatible with the IAU 2000 resolutions, except that
accuracy has been compromised for the sake of speed and convenience in
two respects:

@itemize
@item
UT is used instead of TDB (or TT) to compute the precession component of
GMST and the equation of the equinoxes.  This results in errors of order
@math{0.1} mas at present.

@item
The IAU 2000B abridged nutation model (McCarthy & Luzum, 2001) is used,
introducing errors of up to @math{1} mas.
@end itemize

@item
This GAST is compatible with the IAU 2000 resolutions and must be used
only in conjunction with other IAU 2000 compatible components such as
precession-nutation.

@item
The result is returned in the range 0 to 2pi.

@item
The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003.
@end enumerate

Called:

@table @code
@item iauGmst00
Greenwich mean sidereal time, IAU 2000.

@item iauEe00b
Equation of the equinoxes, IAU 2000B.

@item iauAnp
Normalize angle into range 0 to 2pi.
@end table

References:

@itemize
@item
Capitaine, N., Wallace, P.T. and McCarthy, D.D., ``Expressions to
implement the IAU 2000 definition of UT1'', Astronomy & Astrophysics,
406, 1135-1149 (2003)

@item
McCarthy, D.D. & Luzum, B.J., ``An abridged model of the
precession--nutation of the celestial pole'', Celestial Mechanics &
Dynamical Astronomy, 85, 37-49 (2003).

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauGst06 (double @var{uta}, double @var{utb}, double @var{tta}, double @var{ttb}, double @var{rnpb}[3][3])
Greenwich apparent sidereal time, IAU 2006, given the NPB matrix.

Status: support function.

Given:

@example
uta,utb  double        UT1 as a 2-part Julian Date (Notes 1,2)
tta,ttb  double        TT as a 2-part Julian Date (Notes 1,2)
rnpb     double[3][3]  nutation x precession x bias matrix
@end example

Returned (function value):

@example
double        Greenwich apparent sidereal time (radians)
@end example

Notes:

@enumerate
@item
The UT1 and TT dates @code{@var{uta} + @var{utb}} and @code{@var{tta} +
@var{ttb}} respectively, are both Julian Dates, apportioned in any
convenient way between the argument pairs.  For example, @code{JD =
2450123.7} could be expressed in any of these ways, among others:

@example
   Part A        Part B

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable (in the
case of UT; the TT is not at all critical in this respect).  The J2000
and MJD methods are good compromises between resolution and convenience.
For UT, the date & time method is best matched to the algorithm that is
used by the Earth rotation angle function, called internally: maximum
precision is delivered when the @var{uta} argument is for 0hrs UT1 on
the day in question and the @var{utb} argument lies in the range 0 to 1,
or vice versa.

@item
Both UT1 and TT are required, UT1 to predict the Earth rotation and TT
to predict the effects of precession--nutation.  If UT1 is used for both
purposes, errors of order 100 microarcseconds result.

@item
Although the function uses the IAU 2006 series for @code{s + XY/2}, it
is otherwise independent of the precession--nutation model and can in
practice be used with any equinox--based NPB matrix.

@item
The result is returned in the range 0 to 2pi.
@end enumerate

Called:

@table @code
@item iauBpn2xy
Extract CIP X,Y coordinates from NPB matrix.

@item iauS06
The CIO locator @math{s}, given X,Y, IAU 2006.

@item iauAnp
Normalize angle into range 0 to 2pi.

@item iauEra00
Earth rotation angle, IAU 2000.

@item iauEors
Equation of the origins, given NPB matrix and @var{s}.
@end table

Reference:

@itemize
@item
Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauGst06a (double @var{uta}, double @var{utb}, double @var{tta}, double @var{ttb})
Greenwich apparent sidereal time (consistent with IAU 2000 and 2006
resolutions).

Status: canonical model.

Given:

@example
uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
tta,ttb    double    TT as a 2-part Julian Date (Notes 1,2)
@end example

Returned (function value):

@example
           double    Greenwich apparent sidereal time (radians)
@end example

Notes:

@enumerate
@item
The UT1 and TT dates @code{@var{uta} + @var{utb}} and @code{@var{tta} +
@var{ttb}} respectively, are both Julian Dates, apportioned in any
convenient way between the argument pairs.  For example, @code{JD =
2450123.7} could be expressed in any of these ways, among others:

@example
   Part A        Part B

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable (in the
case of UT; the TT is not at all critical in this respect).  The J2000
and MJD methods are good compromises between resolution and convenience.
For UT, the date & time method is best matched to the algorithm that is
used by the Earth rotation angle function, called internally: maximum
precision is delivered when the @var{uta} argument is for 0hrs UT1 on
the day in question and the @var{utb} argument lies in the range 0 to 1,
or vice versa.

@item
Both UT1 and TT are required, UT1 to predict the Earth rotation and TT
to predict the effects of precession-nutation.  If UT1 is used for both
purposes, errors of order 100 microarcseconds result.

@item
This GAST is compatible with the IAU 2000/2006 resolutions and must be
used only in conjunction with IAU 2006 precession and IAU 2000A
nutation.

@item
The result is returned in the range 0 to 2pi.
@end enumerate

Called:

@table @code
@item iauPnm06a
Classical NPB matrix, IAU 2006/2000A.

@item iauGst06
Greenwich apparent ST, IAU 2006, given NPB matrix.
@end table

Reference:

@itemize
@item
Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauGst94 (double @var{uta}, double @var{utb})
Greenwich apparent sidereal time (consistent with IAU 1982/94
resolutions).

Status: support function.

Given:

@example
uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
@end example

Returned (function value):

@example
           double    Greenwich apparent sidereal time (radians)
@end example

Notes:

@enumerate
@item
The UT1 date @code{@var{uta} + @var{utb}} is a Julian Date, apportioned
in any convenient way between the argument pair.  For example, @code{JD
= 2450123.7} could be expressed in any of these ways, among others:

@example
    uta            utb

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  For UT, the date & time method is best matched to the
algorithm that is used by the Earth Rotation Angle function, called
internally: maximum precision is delivered when the @var{uta} argument
is for 0hrs UT1 on the day in question and the @var{utb} argument lies
in the range 0 to 1, or vice versa.

@item
The result is compatible with the IAU 1982 and 1994 resolutions, except
that accuracy has been compromised for the sake of convenience in that
UT is used instead of TDB (or TT) to compute the equation of the
equinoxes.

@item
This GAST must be used only in conjunction with contemporaneous IAU
standards such as 1976 precession, 1980 obliquity and 1982 nutation.  It
is not compatible with the IAU 2000 resolutions.

@item
The result is returned in the range 0 to 2pi.
@end enumerate

Called:

@table @code
@item iauGmst82
Greenwich mean sidereal time, IAU 1982.

@item iauEqeq94
Equation of the equinoxes, IAU 1994.

@item iauAnp
Normalize angle into range 0 to 2pi.
@end table

References:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).

@item
IAU Resolution C7, Recommendation 3 (1994).
@end itemize
@end deftypefun

@c page
@node api SpaceMotion
@subsection Space motion


@deftypefun int iauPvstar (double @var{pv}[2][3], double * @var{ra}, double * @var{dec}, double * @var{pmr}, double * @var{pmd}, double * @var{px}, double * @var{rv})
Convert star position+velocity vector to catalog coordinates.

Status: support function.

Given (Note 1):

@example
pv     double[2][3]   pv-vector (AU, AU/day)
@end example

Returned (Note 2):

@example
ra     double         right ascension (radians)
dec    double         declination (radians)
pmr    double         RA proper motion (radians/year)
pmd    double         Dec proper motion (radians/year)
px     double         parallax (arcsec)
rv     double         radial velocity (km/s, positive = receding)
@end example

Returned (function value):

@example
int            status:
                  0 = OK
                 -1 = superluminal speed (Note 5)
                 -2 = null position vector
@end example

Notes:

@enumerate
@item
The specified @var{pv}-vector is the coordinate direction (and its rate
of change) for the date at which the light leaving the star reached the
solar--system barycenter.

@item
The star data returned by this function are ``observables'' for an
imaginary observer at the solar--system barycenter.  Proper motion and
radial velocity are, strictly, in terms of barycentric coordinate time,
TCB.  For most practical applications, it is permissible to neglect the
distinction between TCB and ordinary ``proper'' time on Earth (TT/TAI).
The result will, as a rule, be limited by the intrinsic accuracy of the
proper--motion and radial--velocity data; moreover, the supplied
@var{pv}-vector is likely to be merely an intermediate result (for
example generated by the function iauStarpv), so that a change of time
unit will cancel out overall.

In accordance with normal star--catalog conventions, the object's right
ascension and declination are freed from the effects of secular
aberration.  The frame, which is aligned to the catalog equator and
equinox, is Lorentzian and centered on the SSB.

Summarizing, the specified @var{pv}-vector is for most stars almost
identical to the result of applying the standard geometrical ``space
motion'' transformation to the catalog data.  The differences, which are
the subject of the Stumpff paper cited below, are:

@enumerate a
@item
In stars with significant radial velocity and proper motion, the
constantly changing light--time distorts the apparent proper motion.
Note that this is a classical, not a relativistic, effect.

@item
The transformation complies with special relativity.
@end enumerate

@item
Care is needed with units.  The star coordinates are in radians and the
proper motions in radians per Julian year, but the parallax is in
arcseconds; the radial velocity is in km/s, but the @var{pv}-vector
result is in AU and AU/day.

@item
The proper motions are the rate of change of the right ascension and
declination at the catalog epoch and are in radians per Julian year.
The RA proper motion is in terms of coordinate angle, not true angle,
and will thus be numerically larger at high declinations.

@item
Straight--line motion at constant speed in the inertial frame is
assumed.  If the speed is greater than or equal to the speed of light,
the function aborts with an error status.

@item
The inverse transformation is performed by the function iauStarpv.
@end enumerate

Called:

@table @code
@item iauPn
Decompose @code{p}-vector into modulus and direction.

@item iauPdp
Scalar product of two @code{p}-vectors.

@item iauSxp
Multiply @code{p}-vector by scalar.

@item iauPmp
@code{p}-vector minus @code{p}-vector.

@item iauPm
Modulus of @code{p}-vector.

@item iauPpp
@code{p}-vector plus @code{p}-vector.

@item iauPv2s
@code{pv}-vector to spherical.

@item iauAnp
Normalize angle into range 0 to 2pi.
@end table

Reference:

@itemize
@item
Stumpff, P., 1985, Astron.Astrophys. 144, 232-240.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauStarpv (double @var{ra}, double @var{dec}, double @var{pmr}, double @var{pmd}, double @var{px}, double @var{rv}, double @var{pv}[2][3])
Convert star catalog coordinates to position+velocity vector.

Status: support function.

Given (Note 1):

@example
ra     double        right ascension (radians)
dec    double        declination (radians)
pmr    double        RA proper motion (radians/year)
pmd    double        Dec proper motion (radians/year)
px     double        parallax (arcseconds)
rv     double        radial velocity (km/s, positive = receding)
@end example

Returned (Note 2):

@example
pv     double[2][3]  pv-vector (AU, AU/day)
@end example

Returned (function value):

@example
int           status:
                  0 = no warnings
                  1 = distance overridden (Note 6)
                  2 = excessive speed (Note 7)
                  4 = solution didn't converge (Note 8)
               else = binary logical OR of the above
@end example

Notes:

@enumerate
@item
The star data accepted by this function are ``observables'' for an
imaginary observer at the solar--system barycenter.  Proper motion and
radial velocity are, strictly, in terms of barycentric coordinate time,
TCB.  For most practical applications, it is permissible to neglect the
distinction between TCB and ordinary ``proper'' time on Earth (TT/TAI).
The result will, as a rule, be limited by the intrinsic accuracy of the
proper--motion and radial--velocity data; moreover, the @var{pv}-vector
is likely to be merely an intermediate result, so that a change of time
unit would cancel out overall.

In accordance with normal star--catalog conventions, the object's right
ascension and declination are freed from the effects of secular
aberration.  The frame, which is aligned to the catalog equator and
equinox, is Lorentzian and centered on the SSB.

@item
The resulting position and velocity @var{pv}-vector is with respect to
the same frame and, like the catalog coordinates, is freed from the
effects of secular aberration.  Should the ``coordinate direction'',
where the object was located at the catalog epoch, be required, it may
be obtained by calculating the magnitude of the position vector
@code{@var{pv}[0][0-2]} dividing by the speed of light in AU/day to give
the light--time, and then multiplying the space velocity
@code{@var{pv}[1][0-2]} by this light--time and adding the result to
@code{@var{pv}[0][0-2]}.

Summarizing, the @var{pv}-vector returned is for most stars almost
identical to the result of applying the standard geometrical ``space
motion'' transformation.  The differences, which are the subject of the
Stumpff paper referenced below, are:

@itemize a
@item
In stars with significant radial velocity and proper motion, the
constantly changing light--time distorts the apparent proper motion.
Note that this is a classical, not a relativistic, effect.

@item
The transformation complies with special relativity.
@end itemize

@item
Care is needed with units.  The star coordinates are in radians and the
proper motions in radians per Julian year, but the parallax is in
arcseconds; the radial velocity is in @math{km/s}, but the
@var{pv}-vector result is in AU and AU/day.

@item
The RA proper motion is in terms of coordinate angle, not true angle.
If the catalog uses arcseconds for both RA and Dec proper motions, the
RA proper motion will need to be divided by @code{cos(Dec)} before use.

@item
Straight--line motion at constant speed, in the inertial frame, is
assumed.

@item
An extremely small (or zero or negative) parallax is interpreted to mean
that the object is on the ``celestial sphere'', the radius of which is
an arbitrary (large) value (see the constant @code{PXMIN}).  When the
distance is overridden in this way, the status, initially zero, has
@math{1} added to it.

@item
If the space velocity is a significant fraction of @math{c} (see the
constant @code{VMAX}), it is arbitrarily set to zero.  When this action
occurs, @math{2} is added to the status.

@item
The relativistic adjustment involves an iterative calculation.  If the
process fails to converge within a set number (@code{IMAX}) of
iterations, @math{4} is added to the status.

@item
The inverse transformation is performed by the function
@code{iauPvstar}.
@end enumerate

Called:

@table @code
@item iauS2pv
Spherical coordinates to @var{pv}-vector.

@item iauPm
Modulus of @code{p}-vector.

@item iauZp
Zero @code{p}-vector.

@item iauPn
Decompose @code{p}-vector into modulus and direction.

@item iauPdp
Scalar product of two @code{p}-vectors.

@item iauSxp
Multiply @code{p}-vector by scalar.

@item iauPmp
@code{p}-vector minus @code{p}-vector.

@item iauPpp
@code{p}-vector plus @code{p}-vector.
@end table

Reference:

@itemize
@item
Stumpff, P., 1985, Astron.Astrophys. 144, 232-240.
@end itemize
@end deftypefun

@c page
@node api StarCatalogs
@subsection Star catalogs


@deftypefun void iauFk52h (double @var{r5}, double @var{d5}, double @var{dr5}, double @var{dd5}, double @var{px5}, double @var{rv5}, double * @var{rh}, double * @var{dh}, double * @var{drh}, double * @var{ddh}, double * @var{pxh}, double * @var{rvh})
Transform FK5 (J2000.0) star data into the Hipparcos system.

Status: support function.

Given (all FK5, equinox J2000.0, epoch J2000.0):

@example
r5      double    RA (radians)
d5      double    Dec (radians)
dr5     double    proper motion in RA (dRA/dt, rad/Jyear)
dd5     double    proper motion in Dec (dDec/dt, rad/Jyear)
px5     double    parallax (arcsec)
rv5     double    radial velocity (km/s, positive = receding)
@end example

Returned (all Hipparcos, epoch J2000.0):

@example
rh      double    RA (radians)
dh      double    Dec (radians)
drh     double    proper motion in RA (dRA/dt, rad/Jyear)
ddh     double    proper motion in Dec (dDec/dt, rad/Jyear)
pxh     double    parallax (arcsec)
rvh     double    radial velocity (km/s, positive = receding)
@end example

Notes:

@enumerate
@item
This function transforms FK5 star positions and proper motions into the
system of the Hipparcos catalog.

@item
The proper motions in RA are @code{dRA/dt} rather than @code{cos(Dec) *
dRA/dt}, and are per year rather than per century.

@item
The FK5 to Hipparcos transformation is modeled as a pure rotation and
spin; zonal errors in the FK5 catalog are not taken into account.

@item
See also @code{iauH2fk5}, @code{iauFk5hz}, @code{iauHfk5z}.
@end enumerate

Called:

@table @code
@item iauStarpv
Star catalog data to space motion @code{pv}-vector.

@item iauFk5hip
FK5 to Hipparcos rotation and spin.

@item iauRxp
Product of @code{r}-matrix and @code{p}-vector.

@item iauPxp
Vector product of two @code{p}-vectors.

@item iauPpp
@code{p}-vector plus @code{p}-vector.

@item iauPvstar
Space motion @code{pv}-vector to star catalog data.
@end table

Reference:

@itemize
@item
F.Mignard & M.Froeschle, Astron. Astrophys. 354, 732-739 (2000).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauFk5hip (double @var{r5h}[3][3], double @var{s5h}[3])
FK5 to Hipparcos rotation and spin.

Status: support function.

Returned:

@example
r5h   double[3][3]  r-matrix: FK5 rotation wrt Hipparcos (Note 2)
s5h   double[3]     r-vector: FK5 spin wrt Hipparcos (Note 3)
@end example

Notes:

@enumerate
@item
This function models the FK5 to Hipparcos transformation as a pure
rotation and spin; zonal errors in the FK5 catalogue are not taken into
account.

@item
The @code{r}-matrix @var{r5h} operates in the sense:

@example
P_Hipparcos = r5h x P_FK5
@end example

@noindent
where @code{P_FK5} is a @code{p}-vector in the FK5 frame, and
@code{P_Hipparcos} is the equivalent Hipparcos @code{p}-vector.

@item
The @code{r}-vector @var{s5h} represents the time derivative of the FK5
to Hipparcos rotation.  The units are radians per year (Julian, TDB).
@end enumerate

Called:

@table @code
@item iauRv2m
@code{r}-vector to @code{r}-matrix.
@end table

Reference:

@itemize
@item
F.Mignard & M.Froeschle, Astron. Astrophys. 354, 732-739 (2000).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauFk5hz (double @var{r5}, double @var{d5}, double @vari{date}, double @varii{date}, double * @var{rh}, double * @var{dh})
Transform an FK5 (J2000.0) star position into the system of the
Hipparcos catalogue, assuming zero Hipparcos proper motion.

Status: support function.

Given:

@example
r5           double   FK5 RA (radians), equinox J2000.0, at date
d5           double   FK5 Dec (radians), equinox J2000.0, at date
date1,date2  double   TDB date (Notes 1,2)
@end example

Returned:

@example
rh           double   Hipparcos RA (radians)
dh           double   Hipparcos Dec (radians)
@end example

Notes:

@enumerate
@item
This function converts a star position from the FK5 system to the
Hipparcos system, in such a way that the Hipparcos proper motion is
zero.  Because such a star has, in general, a non-zero proper motion in
the FK5 system, the function requires the date at which the position in
the FK5 system was determined.

@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The FK5 to Hipparcos transformation is modeled as a pure rotation and
spin; zonal errors in the FK5 catalogue are not taken into account.

@item
The position returned by this function is in the Hipparcos reference
system but at date date1+date2.

@item
See also @code{iauFk52h}, @code{iauH2fk5}, @code{iauHfk5z}.
@end enumerate

Called:

@table @code
@item iauS2c
Spherical coordinates to unit vector.

@item iauFk5hip
FK5 to Hipparcos rotation and spin.

@item iauSxp
Multiply @code{p}-vector by scalar.

@item iauRv2m
@code{r}-vector to @code{r}-matrix.

@item iauTrxp
Product of transpose of @code{r}-matrix and @code{p}-vector.

@item iauPxp
Vector product of two @code{p}-vectors.

@item iauC2s
@code{p}-vector to spherical.

@item iauAnp
Normalize angle into range 0 to 2pi.
@end table

Reference:

@itemize
@item
F.Mignard & M.Froeschle, 2000, Astron.Astrophys. 354, 732-739.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauH2fk5 (double @var{rh}, double @var{dh}, double @var{drh}, double @var{ddh}, double @var{pxh}, double @var{rvh}, double * @var{r5}, double * @var{d5}, double * @var{dr5}, double * @var{dd5}, double * @var{px5}, double * @var{rv5})
Transform Hipparcos star data into the FK5 (J2000.0) system.

Status: support function.

Given (all Hipparcos, epoch J2000.0):

@example
rh      double    RA (radians)
dh      double    Dec (radians)
drh     double    proper motion in RA (dRA/dt, rad/Jyear)
ddh     double    proper motion in Dec (dDec/dt, rad/Jyear)
pxh     double    parallax (arcsec)
rvh     double    radial velocity (km/s, positive = receding)
@end example

Returned (all FK5, equinox J2000.0, epoch J2000.0):

@example
r5      double    RA (radians)
d5      double    Dec (radians)
dr5     double    proper motion in RA (dRA/dt, rad/Jyear)
dd5     double    proper motion in Dec (dDec/dt, rad/Jyear)
px5     double    parallax (arcsec)
rv5     double    radial velocity (km/s, positive = receding)
@end example

Notes:

@enumerate
@item
This function transforms Hipparcos star positions and proper motions
into FK5 J2000.0.

@item
The proper motions in RA are @code{dRA/dt} rather than @code{cos(Dec) *
dRA/dt}, and are per year rather than per century.

@item
The FK5 to Hipparcos transformation is modeled as a pure rotation and
spin; zonal errors in the FK5 catalog are not taken into account.

@item
See also @code{iauFk52h}, @code{iauFk5hz}, @code{iauHfk5z}.
@end enumerate

Called:

@table @code
@item iauStarpv
Star catalog data to space motion @code{pv}-vector.

@item iauFk5hip
FK5 to Hipparcos rotation and spin.

@item iauRv2m
@code{r}-vector to @code{r}-matrix.

@item iauRxp
Product of @code{r}-matrix and @code{p}-vector.

@item iauTrxp
Product of transpose of @code{r}-matrix and @code{p}-vector.

@item iauPxp
Vector product of two @code{p}-vectors.

@item iauPmp
@code{p}-vector minus @code{p}-vector.

@item iauPvstar
Space motion @code{pv}-vector to star catalog data.
@end table

Reference:

@itemize
@item
F.Mignard & M.Froeschle, Astron. Astrophys. 354, 732-739 (2000).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauHfk5z (double @var{rh}, double @var{dh}, double @vari{date}, double @varii{date}, double * @var{r5}, double * @var{d5}, double * @var{dr5}, double * @var{dd5})
Transform a Hipparcos star position into FK5 J2000.0, assuming zero
Hipparcos proper motion.

Status: support function.

Given:

@example
rh            double    Hipparcos RA (radians)
dh            double    Hipparcos Dec (radians)
date1,date2   double    TDB date (Note 1)
@end example

Returned (all FK5, equinox J2000.0, date @code{@vari{date} +
@varii{date}}):

@example
r5            double    RA (radians)
d5            double    Dec (radians)
dr5           double    FK5 RA proper motion (rad/year, Note 4)
dd5           double    Dec proper motion (rad/year, Note 4)
@end example

Notes:

@enumerate
@item
The TT date @code{@vari{date} + @varii{date}} is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, @code{JD(TT) = 2450123.7} could be expressed in any of these
ways, among others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
The proper motion in RA is @code{dRA/dt} rather than @code{cos(Dec) *
dRA/dt}.

@item
The FK5 to Hipparcos transformation is modeled as a pure rotation and
spin; zonal errors in the FK5 catalogue are not taken into account.

@item
It was the intention that Hipparcos should be a close approximation to
an inertial frame, so that distant objects have zero proper motion; such
objects have (in general) non-zero proper motion in FK5, and this
function returns those fictitious proper motions.

@item
The position returned by this function is in the FK5 J2000.0 reference
system but at date @code{@vari{date} + @varii{date}}.

@item
See also @code{iauFk52h}, @code{iauH2fk5}, @code{iauFk5zhz}.
@end enumerate

Called:

@table @code
@item iauS2c
Spherical coordinates to unit vector.

@item iauFk5hip
FK5 to Hipparcos rotation and spin.

@item iauRxp
Product of @code{r}-matrix and @code{p}-vector.

@item iauSxp
Multiply @code{p}-vector by scalar.

@item iauRxr
Product of two @code{r}-matrices.

@item iauTrxp
Product of transpose of @code{r}-matrix and @code{p}-vector.

@item iauPxp
Vector product of two @code{p}-vectors.

@item iauPv2s
@code{pv}-vector to spherical.

@item iauAnp
Normalize angle into range 0 to 2pi.
@end table

Reference:

@itemize
@item
F.Mignard & M.Froeschle, 2000, Astron.Astrophys. 354, 732-739.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauStarpm (double @var{ra1}, double @var{dec1}, double @var{pmr1}, double @var{pmd1}, double @var{px1}, double @var{rv1}, double @var{ep1a}, double @var{ep1b}, double @var{ep2a}, double @var{ep2b}, double * @var{ra2}, double * @var{dec2}, double * @var{pmr2}, double * @var{pmd2}, double * @var{px2}, double * @var{rv2})
Star proper motion: update star catalog data for space motion.

Status: support function.

Given:

@example
ra1    double     right ascension (radians), before
dec1   double     declination (radians), before
pmr1   double     RA proper motion (radians/year), before
pmd1   double     Dec proper motion (radians/year), before
px1    double     parallax (arcseconds), before
rv1    double     radial velocity (km/s, +ve = receding), before
ep1a   double     "before" epoch, part A (Note 1)
ep1b   double     "before" epoch, part B (Note 1)
ep2a   double     "after" epoch, part A (Note 1)
ep2b   double     "after" epoch, part B (Note 1)
@end example

Returned:

@example
ra2    double     right ascension (radians), after
dec2   double     declination (radians), after
pmr2   double     RA proper motion (radians/year), after
pmd2   double     Dec proper motion (radians/year), after
px2    double     parallax (arcseconds), after
rv2    double     radial velocity (km/s, +ve = receding), after
@end example

Returned (function value):

@example
int        status:
              -1 = system error (should not occur)
               0 = no warnings or errors
               1 = distance overridden (Note 6)
               2 = excessive velocity (Note 7)
               4 = solution didn't converge (Note 8)
            else = binary logical OR of the above warnings
@end example

Notes:

@enumerate
@item
The starting and ending TDB dates @code{@var{ep1a} + @var{ep1b}} and
@code{@var{ep2a} + @var{ep2b}} are Julian Dates, apportioned in any
convenient way between the two parts (A and B).  For example,
@code{JD(TDB) = 2450123.7} could be expressed in any of these ways,
among others:

@example
    epna          epnb

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

@item
In accordance with normal star--catalog conventions, the object's right
ascension and declination are freed from the effects of secular
aberration.  The frame, which is aligned to the catalog equator and
equinox, is Lorentzian and centered on the SSB.

The proper motions are the rate of change of the right ascension and
declination at the catalog epoch and are in radians per TDB Julian year.

The parallax and radial velocity are in the same frame.

@item
Care is needed with units.  The star coordinates are in radians and the
proper motions in radians per Julian year, but the parallax is in
arcseconds.

@item
The RA proper motion is in terms of coordinate angle, not true angle.
If the catalog uses arcseconds for both RA and Dec proper motions, the
RA proper motion will need to be divided by @code{cos(Dec)} before use.

@item
Straight--line motion at constant speed, in the inertial frame, is
assumed.

@item
An extremely small (or zero or negative) parallax is interpreted to mean
that the object is on the ``celestial sphere'', the radius of which is
an arbitrary (large) value (see the @code{iauStarpv} function for the
value used).  When the distance is overridden in this way, the status,
initially zero, has @math{1} added to it.

@item
If the space velocity is a significant fraction of @math{c} (see the
constant @code{VMAX} in the function @code{iauStarpv}), it is
arbitrarily set to zero.  When this action occurs, @math{2} is added to
the status.

@item
The relativistic adjustment carried out in the @code{iauStarpv} function
involves an iterative calculation.  If the process fails to converge
within a set number of iterations, @math{4} is added to the status.
@end enumerate

Called:

@table @code
@item iauStarpv
Star catalog data to space motion @code{pv}-vector.

@item iauPvu
Update a @var{pv}-vector.

@item iauPdp
Scalar product of two @code{p}-vectors.

@item iauPvstar
Space motion @code{pv}-vector to star catalog data.
@end table
@end deftypefun

@c page
@node api Geodetic/Geocentric
@subsection Geodetic geocentric


@deftypefun int iauEform (int @var{n}, double * @var{a}, double * @var{f})
Earth reference ellipsoids.

Status: canonical.

Given:

@example
n    int         ellipsoid identifier (Note 1)
@end example

Returned:

@example
a    double      equatorial radius (meters, Note 2)
f    double      flattening (Note 2)
@end example

Returned (function value):

@example
int         status:  0 = OK
                    -1 = illegal identifier (Note 3)
@end example

Notes:

@enumerate
@item
The identifier @var{n} is a number that specifies the choice of
reference ellipsoid.  The following are supported:

@example
n    ellipsoid

1     WGS84
2     GRS80
3     WGS72
@end example

The @var{n} value has no significance outside the @sofa{} software.  For
convenience, symbols WGS84 etc. are defined in @file{sofam.h}.

@item
The ellipsoid parameters are returned in the form of equatorial radius
in meters (a) and flattening (f).  The latter is a number around
@math{0.00335}, i.e. around @math{1/298}.

@item
For the case where an unsupported @var{n} value is supplied, zero
@var{a} and @var{f} are returned, as well as error status.
@end enumerate

References:

@itemize
@item
Department of Defense World Geodetic System 1984, National Imagery and
Mapping Agency Technical Report 8350.2, Third Edition, p3-2.

@item
Moritz, H., Bull. Geodesique 66-2, 187 (1992).

@item
The Department of Defense World Geodetic System 1972, World Geodetic
System Committee, May 1974.

@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), p220.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauGc2gd (int @var{n}, double @var{xyz}[3], double * @var{elong}, double * @var{phi}, double * @var{height})
Transform geocentric coordinates to geodetic using the specified
reference ellipsoid.

Status: canonical transformation.

Given:

@example
n       int        ellipsoid identifier (Note 1)
xyz     double[3]  geocentric vector (Note 2)
@end example

Returned:

@example
elong   double     longitude (radians, east +ve)
phi     double     latitude (geodetic, radians, Note 3)
height  double     height above ellipsoid (geodetic, Notes 2,3)
@end example

Returned (function value):

@example
int         status:  0 = OK
                    -1 = illegal identifier (Note 3)
                    -2 = internal error (Note 3)
@end example

Notes:

@enumerate
@item
The identifier @var{n} is a number that specifies the choice of
reference ellipsoid.  The following are supported:

@example
n    ellipsoid

1     WGS84
2     GRS80
3     WGS72
@end example

The @var{n} value has no significance outside the @sofa{} software.  For
convenience, symbols WGS84 etc. are defined in @file{sofam.h}.

@item
The geocentric vector (xyz, given) and height (height, returned) are in
meters.

@item
An error status -1 means that the identifier @var{n} is illegal.  An
error status -2 is theoretically impossible.  In all error cases, phi
and height are both set to -1e9.

@item
The inverse transformation is performed in the function @code{iauGd2gc}.
@end enumerate

Called:

@table @code
@item iauEform
Earth reference ellipsoids.

@item iauGc2gde
Geocentric to geodetic transformation, general.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauGc2gde (double @var{a}, double @var{f}, double @var{xyz}[3], double * @var{elong}, double * @var{phi}, double * @var{height})
Transform geocentric coordinates to geodetic for a reference ellipsoid
of specified form.

Status: support function.

Given:

@example
a       double     equatorial radius (Notes 2,4)
f       double     flattening (Note 3)
xyz     double[3]  geocentric vector (Note 4)
@end example

Returned:

@example
elong   double     longitude (radians, east +ve)
phi     double     latitude (geodetic, radians)
height  double     height above ellipsoid (geodetic, Note 4)
@end example

Returned (function value):

@example
int        status:  0 = OK
                   -1 = illegal f
                   -2 = illegal a
@end example

Notes:

@enumerate
@item
This function is based on the GCONV2H Fortran subroutine by Toshio
Fukushima (see reference).

@item
The equatorial radius, a, can be in any units, but meters is the
conventional choice.

@item
The flattening, f, is (for the Earth) a value around 0.00335,
i.e. around 1/298.

@item
The equatorial radius, a, and the geocentric vector, xyz, must be given
in the same units, and determine the units of the returned height,
height.

@item
If an error occurs (status < 0), elong, phi and height are unchanged.

@item
The inverse transformation is performed in the function
@code{iauGd2gce}.

@item
The transformation for a standard ellipsoid (such as WGS84) can more
conveniently be performed by calling iauGc2gd, which uses a numerical
code to identify the required A and F values.
@end enumerate

Reference:

@itemize
@item
Fukushima, T., ``Transformation from Cartesian to geodetic coordinates
accelerated by Halley's method'', J.Geodesy (2006) 79: 689-693
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauGd2gc (int @var{n}, double @var{elong}, double @var{phi}, double @var{height}, double @var{xyz}[3])
Transform geodetic coordinates to geocentric using the specified
reference ellipsoid.

Status: canonical transformation.

Given:

@example
n       int        ellipsoid identifier (Note 1)
elong   double     longitude (radians, east +ve)
phi     double     latitude (geodetic, radians, Note 3)
height  double     height above ellipsoid (geodetic, Notes 2,3)
@end example

Returned:

@example
xyz     double[3]  geocentric vector (Note 2)
@end example

Returned (function value):

@example
int        status:  0 = OK
                   -1 = illegal identifier (Note 3)
                   -2 = illegal case (Note 3)
@end example

Notes:

@enumerate
@item
The identifier @var{n} is a number that specifies the choice of
reference ellipsoid.  The following are supported:

@example
n    ellipsoid

1     WGS84
2     GRS80
3     WGS72
@end example

The @var{n} value has no significance outside the @sofa{} software.  For
convenience, symbols WGS84 etc. are defined in @file{sofam.h}.

@item
The height (height, given) and the geocentric vector (xyz, returned) are
in meters.

@item
No validation is performed on the arguments elong, phi and height.  An
error status -1 means that the identifier n is illegal.  An error status
-2 protects against cases that would lead to arithmetic exceptions.  In
all error cases, xyz is set to zeros.

@item
The inverse transformation is performed in the function @code{iauGc2gd}.
@end enumerate

Called:

@table @code
@item iauEform
Earth reference ellipsoids.

@item iauGd2gce
Geodetic to geocentric transformation, general.

@item iauZp
Zero @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauGd2gce (double @var{a}, double @var{f}, double @var{elong}, double @var{phi}, double @var{height}, double @var{xyz}[3])
Transform geodetic coordinates to geocentric for a reference ellipsoid
of specified form.

Status: support function.

Given:

@example
a       double     equatorial radius (Notes 1,4)
f       double     flattening (Notes 2,4)
elong   double     longitude (radians, east +ve)
phi     double     latitude (geodetic, radians, Note 4)
height  double     height above ellipsoid (geodetic, Notes 3,4)
@end example

Returned:

@example
xyz     double[3]  geocentric vector (Note 3)
@end example

Returned (function value):

@example
int        status:  0 = OK
                   -1 = illegal case (Note 4)
@end example

Notes:

@enumerate
@item
The equatorial radius, a, can be in any units, but meters is the
conventional choice.

@item
The flattening, f, is (for the Earth) a value around 0.00335,
i.e. around 1/298.

@item
The equatorial radius, a, and the height, height, must be given in the
same units, and determine the units of the returned geocentric vector,
xyz.

@item
No validation is performed on individual arguments.  The error status -1
protects against (unrealistic) cases that would lead to arithmetic
exceptions.  If an error occurs, xyz is unchanged.

@item
The inverse transformation is performed in the function
@code{iauGc2gde}.

@item
The transformation for a standard ellipsoid (such as WGS84) can more
conveniently be performed by calling @code{iauGd2gc}, which uses a
numerical code to identify the required a and f values.
@end enumerate

References:

@itemize
@item
Green, R.M., Spherical Astronomy, Cambridge University Press, (1985)
Section 4.5, p96.

@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 4.22, p202.
@end itemize
@end deftypefun

@c page
@node api Timescales
@subsection Timescales


@deftypefun int iauD2dtf (const char * @var{scale}, int @var{ndp}, double @var{d1}, double @var{d2}, int * @var{iy}, int * @var{im}, int * @var{id}, int @var{ihmsf}[4])
Format for output a 2-part Julian Date (or in the case of UTC a quasi-JD
form that includes special provision for leap seconds).

Status: support function.

Given:

@example
scale     char[]  time scale ID (Note 1)
ndp       int     resolution (Note 2)
d1,d2     double  time as a 2-part Julian Date (Notes 3,4)
@end example

Returned:

@example
iy,im,id  int     year, month, day in Gregorian calendar (Note 5)
ihmsf     int[4]  hours, minutes, seconds, fraction (Note 1)
@end example

Returned (function value):

@example
int     status: +1 = dubious year (Note 5)
                 0 = OK
                -1 = unacceptable date (Note 6)
@end example

Notes:

@enumerate
@item
@var{scale} identifies the time scale.  Only the value @code{UTC} (in
upper case) is significant, and enables handling of leap seconds (see
Note 4).

@item
@var{ndp} is the number of decimal places in the seconds field, and can
have negative as well as positive values, such as:

@example
ndp         resolution
-4            1 00 00
-3            0 10 00
-2            0 01 00
-1            0 00 10
 0            0 00 01
 1            0 00 00.1
 2            0 00 00.01
 3            0 00 00.001
@end example

The limits are platform dependent, but a safe range is @math{-5} to
@math{+9}.

@item
@code{@var{d1} + @var{d2}} is Julian Date, apportioned in any convenient
way between the two arguments, for example where @var{d1} is the Julian
Day Number and @var{d2} is the fraction of a day.  In the case of UTC,
where the use of JD is problematical, special conventions apply: see the
next note.

@item
JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The SOFA internal convention is that the
quasi-JD day represents UTC days whether the length is @math{86399},
@math{86400} or @math{86401} SI seconds.

@item
The warning status ``dubious year'' flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See @code{iauDat} for further details.

@item
For calendar conventions and limitations, see @code{iauCal2jd}.
@end enumerate

Called:

@table @code
@item iauJd2cal
JD to Gregorian calendar.

@item iauD2tf
Decompose days to hms.

@item iauDat
@code{delta(AT) = TAI-UTC}.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauDat (int @var{iy}, int @var{im}, int @var{id}, double @var{fd}, double * @var{deltat} )
For a given UTC date, calculate @code{delta(AT) = TAI-UTC}.

@quotation
@strong{IMPORTANT} A new version of this function must be produced
whenever a new leap second is announced.  There are four items to change
on each such occasion:

@enumerate
@item
A new line must be added to the set of statements that initialize the
array ``changes''.

@item
The parameter IYV must be set to the current year.

@item
The ``Latest leap second'' comment below must be set to the new leap
second date.

@item
The ``This revision'' comment, later, must be set to the current date.
@end enumerate

Change (2) must also be carried out whenever the function is re--issued,
even if no leap seconds have been added.

Latest leap second:  2012 June 30
@end quotation

Status: support function.

Given:

@example
iy     int      UTC:  year (Notes 1 and 2)
im     int            month (Note 2)
id     int            day (Notes 2 and 3)
fd     double         fraction of day (Note 4)
@end example

Returned:

@example
deltat double   TAI minus UTC, seconds
@end example

Returned (function value):

@example
int      status (Note 5):
           1 = dubious year (Note 1)
           0 = OK
          -1 = bad year
          -2 = bad month
          -3 = bad day (Note 3)
          -4 = bad fraction (Note 4)
@end example

Notes:

@enumerate
@item
UTC began at 1960 January 1.0 (JD 2436934.5) and it is improper to call
the function with an earlier date.  If this is attempted, zero is
returned together with a warning status.

Because leap seconds cannot, in principle, be predicted in advance, a
reliable check for dates beyond the valid range is impossible.  To guard
against gross errors, a year five or more after the release year of the
present function (see parameter IYV) is considered dubious.  In this
case a warning status is returned but the result is computed in the
normal way.

For both too--early and too--late years, the warning status is @math{j =
+1}.  This is distinct from the error status @math{j = -1}, which
signifies a year so early that JD could not be computed.

@item
If the specified date is for a day which ends with a leap second, the
UTC-TAI value returned is for the period leading up to the leap second.
If the date is for a day which begins as a leap second ends, the UTC-TAI
returned is for the period following the leap second.

@item
The day number must be in the normal calendar range, for example 1
through 30 for April.  The ``almanac'' convention of allowing such dates
as January 0 and December 32 is not supported in this function, in order
to avoid confusion near leap seconds.

@item
The fraction of day is used only for dates before the introduction of
leap seconds, the first of which occurred at the end of 1971.  It is
tested for validity (@math{0} to @math{1} is the valid range) even if
not used; if invalid, zero is used and status @math{j = -4} is returned.
For many applications, setting fd to zero is acceptable; the resulting
error is always less than 3 ms (and occurs only pre-1972).

@item
The status value returned in the case where there are multiple errors
refers to the first error detected.  For example, if the month and day
are 13 and 32 respectively, @math{j = -2} (bad month) will be returned.

@item
In cases where a valid result is not available, zero is returned.
@end enumerate

References:

@enumerate
@item
For dates from 1961 January 1 onwards, the expressions from the file
@url{ftp://maia.usno.navy.mil/ser7/tai-utc.dat} are used.

@item
The 5ms timestep at 1961 January 1 is taken from 2.58.1 (p87) of the
1992 Explanatory Supplement.
@end enumerate

Called:

@table @code
@item iauCal2jd
Gregorian calendar to Julian Day number.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauDtdb (double @vari{date}, double @varii{date}, double @var{ut}, double @var{elong}, double @var{u}, double @var{v})
An approximation to TDB-TT, the difference between barycentric dynamical
time and terrestrial time, for an observer on the Earth.

The different time scales --- proper, coordinate and realized --- are
related to each other:

@example
        TAI             <-  physically realized
         :
      offset            <-  observed (nominally +32.184s)
         :
        TT              <-  terrestrial time
         :
rate adjustment (L_G)   <-  definition of TT
         :
        TCG             <-  time scale for GCRS
         :
  "periodic" terms      <-  iauDtdb  is an implementation
         :
rate adjustment (L_C)   <-  function of solar-system ephemeris
         :
        TCB             <-  time scale for BCRS
         :
rate adjustment (-L_B)  <-  definition of TDB
         :
        TDB             <-  TCB scaled to track TT
         :
  "periodic" terms      <-  -iauDtdb is an approximation
         :
        TT              <-  terrestrial time
@end example

Adopted values for the various constants can be found in the IERS
Conventions (McCarthy & Petit 2003).

Status: support routine.

Given:

@example
date1,date2   double  date, TDB (Notes 1-3)
ut            double  universal time (UT1, fraction of one day)
elong         double  longitude (east positive, radians)
u             double  distance from Earth spin axis (km)
v             double  distance north of equatorial plane (km)
@end example

Returned (function value):

@example
double  TDB-TT (seconds)
@end example

Notes:

@enumerate
@item
The date @code{@vari{date} + @varii{date}} is a Julian Date, apportioned
in any convenient way between the two arguments.  For example,
@code{JD(TT) = 2450123.7} could be expressed in any of these ways, among
others:

@example
   date1          date2

2450123.7           0.0       (JD method)
2451545.0       -1421.3       (J2000 method)
2400000.5       50123.2       (MJD method)
2450123.5           0.2       (date & time method)
@end example

The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date & time methods are both good compromises between resolution and
convenience.

Although the date is, formally, barycentric dynamical time (TDB), the
terrestrial dynamical time (TT) can be used with no practical effect on
the accuracy of the prediction.

@item
TT can be regarded as a coordinate time that is realized as an offset of
32.184s from International Atomic Time, TAI.  TT is a specific linear
transformation of geocentric coordinate time TCG, which is the time
scale for the Geocentric Celestial Reference System, GCRS.

@item
TDB is a coordinate time, and is a specific linear transformation of
barycentric coordinate time TCB, which is the time scale for the
Barycentric Celestial Reference System, BCRS.

@item
The difference TCG-TCB depends on the masses and positions of the bodies
of the solar system and the velocity of the Earth.  It is dominated by a
rate difference, the residual being of a periodic character.  The
latter, which is modeled by the present function, comprises a main
(annual) sinusoidal term of amplitude approximately 0.00166 seconds,
plus planetary terms up to about 20 microseconds, and lunar and diurnal
terms up to 2 microseconds.  These effects come from the changing
transverse Doppler effect and gravitational red-shift as the observer
(on the Earth's surface) experiences variations in speed (with respect
to the BCRS) and gravitational potential.

@item
TDB can be regarded as the same as TCB but with a rate adjustment to
keep it close to TT, which is convenient for many applications.  The
history of successive attempts to define TDB is set out in Resolution 3
adopted by the IAU General Assembly in 2006, which defines a fixed
TDB(TCB) transformation that is consistent with contemporary
solar-system ephemerides.  Future ephemerides will imply slightly
changed transformations between TCG and TCB, which could introduce a
linear drift between TDB and TT; however, any such drift is unlikely to
exceed 1 nanosecond per century.

@item
The geocentric TDB-TT model used in the present function is that of
Fairhead & Bretagnon (1990), in its full form.  It was originally
supplied by Fairhead (private communications with P.T.Wallace, 1990) as
a Fortran subroutine.  The present C function contains an adaptation of
the Fairhead code.  The numerical results are essentially unaffected by
the changes, the differences with respect to the Fairhead & Bretagnon
original being at the 1e-20 s level.

The topocentric part of the model is from Moyer (1981) and Murray
(1983), with fundamental arguments adapted from Simon et al. 1994.  It
is an approximation to the expression @code{( v / c ) . ( r / c )},
where @code{v} is the barycentric velocity of the Earth, @code{r} is the
geocentric position of the observer and @code{c} is the speed of light.

By supplying zeroes for @var{u} and @var{v}, the topocentric part of the
model can be nullified, and the function will return the Fairhead &
Bretagnon result alone.

@item
During the interval 1950-2050, the absolute accuracy is better than +/-
3 nanoseconds relative to time ephemerides obtained by direct numerical
integrations based on the JPL DE405 solar system ephemeris.

@item
It must be stressed that the present function is merely a model, and
that numerical integration of solar-system ephemerides is the definitive
method for predicting the relationship between TCG and TCB and hence
between TT and TDB.
@end enumerate

References:

@itemize
@item
Fairhead, L., & Bretagnon, P., Astron.Astrophys., 229, 240-247 (1990).

@item
IAU 2006 Resolution 3.

@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Moyer, T.D., Cel.Mech., 23, 33 (1981).

@item
Murray, C.A., Vectorial Astrometry, Adam Hilger (1983).

@item
Seidelmann, P.K. et al., Explanatory Supplement to the Astronomical
Almanac, Chapter 2, University Science Books (1992).

@item
Simon, J.L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G. & Laskar, J., Astron.Astrophys., 282, 663-683 (1994).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauDtf2d (const char * @var{scale}, int @var{iy}, int @var{im}, int @var{id}, int @var{ihr}, int @var{imn}, double @var{sec}, double * @var{d1}, double * @var{d2})
Encode date and time fields into 2-part Julian Date (or in the case of
UTC a quasi-JD form that includes special provision for leap seconds).

Status: support function.

Given:

@example
scale     char[]  time scale ID (Note 1)
iy,im,id  int     year, month, day in Gregorian calendar (Note 2)
ihr,imn   int     hour, minute
sec       double  seconds
@end example

Returned:

@example
d1,d2     double  2-part Julian Date (Notes 3,4)
@end example

Returned (function value):

@example
int     status: +3 = both of next two
                +2 = time is after end of day (Note 5)
                +1 = dubious year (Note 6)
                 0 = OK
                -1 = bad year
                -2 = bad month
                -3 = bad day
                -4 = bad hour
                -5 = bad minute
                -6 = bad second (<0)
@end example

Notes:

@enumerate
@item
@var{scale} identifies the time scale.  Only the value @code{UTC} (in
upper case) is significant, and enables handling of leap seconds (see
Note 4).

@item
For calendar conventions and limitations, see iauCal2jd.

@item
The sum of the results, @code{@var{d1} + @var{d2}}, is Julian Date,
where normally @var{d1} is the Julian Day Number and @var{d2} is the
fraction of a day.  In the case of UTC, where the use of JD is
problematical, special conventions apply: see the next note.

@item
JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The @sofa{} internal convention is that the
quasi-JD day represents UTC days whether the length is @math{86399},
@math{86400} or @math{86401} SI seconds.

@item
The warning status ``time is after end of day'' usually means that the
sec argument is greater than @math{60.0}.  However, in a day ending in a
leap second the limit changes to @math{61.0} (or @math{59.0} in the case
of a negative leap second).

@item
The warning status ``dubious year'' flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See @code{iauDat} for further details.

@item
Only in the case of continuous and regular time scales (TAI, TT, TCG,
TCB and TDB) is the result d1+d2 a Julian Date, strictly speaking.  In
the other cases (UT1 and UTC) the result must be used with
circumspection; in particular the difference between two such results
cannot be interpreted as a precise time interval.
@end enumerate

Called:

@table @code
@item iauCal2jd
Gregorian calendar to JD.

@item iauDat
@code{delta(AT) = TAI-UTC}.

@item iauJd2cal
JD to Gregorian calendar.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTaitt (double @vari{tai}, double @varii{tai}, double * @vari{tt}, double * @varii{tt})
Time scale transformation: International Atomic Time, TAI, to
Terrestrial Time, TT.

Status: canonical.

Given:

@example
tai1,tai2  double    TAI as a 2-part Julian Date
@end example

Returned:

@example
tt1,tt2    double    TT as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@code{@vari{tai} + @varii{tai}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @vari{tai}
is the Julian Day Number and @varii{tai} is the fraction of a day.  The
returned @vari{tt}, @varii{tt} follow suit.
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTaiut1 (double @vari{tai}, double @varii{tai}, double @var{dta}, double * @var{ut11}, double * @var{ut12})
Time scale transformation: International Atomic Time, TAI, to Universal
Time, UT1.

Status: canonical.

Given:

@example
tai1,tai2  double    TAI as a 2-part Julian Date
dta        double    UT1-TAI in seconds
@end example

Returned:

@example
ut11,ut12  double    UT1 as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@code{@vari{tai} + @varii{tai}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @vari{tai}
is the Julian Day Number and @varii{tai} is the fraction of a day.  The
returned @var{ut11}, @var{ut12} follow suit.

@item
The argument dta, i.e. UT1-TAI, is an observed quantity, and is
available from IERS tabulations.
@end enumerate

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTaiutc (double @vari{tai}, double @varii{tai}, double * @vari{utc}, double * @varii{utc})
Time scale transformation: International Atomic Time, TAI, to
Coordinated Universal Time, UTC.

Status: canonical.

Given:

@example
tai1,tai2  double   TAI as a 2-part Julian Date (Note 1)
@end example

Returned:

@example
utc1,utc2  double   UTC as a 2-part quasi Julian Date (Notes 1-3)
@end example

Returned (function value):

@example
int      status: +1 = dubious year (Note 4)
                  0 = OK
                 -1 = unacceptable date
@end example

Notes:

@enumerate
@item
@code{@vari{tai} + @varii{tai}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @vari{tai}
is the Julian Day Number and @varii{tai} is the fraction of a day.  The
returned @vari{utc} and @varii{utc} form an analogous pair, except that
a special convention is used, to deal with the problem of leap
seconds---see the next note.

@item
JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The convention in the present function is
that the JD day represents UTC days whether the length is 86399, 86400
or 86401 SI seconds.

@item
The function @code{iauD2dtf} can be used to transform the UTC quasi-JD
into calendar date and clock time, including UTC leap second handling.

@item
The warning status ``dubious year'' flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See @code{iauDat} for further details.
@end enumerate

Called:

@table @code
@item iauJd2cal
JD to Gregorian calendar.

@item iauDat
@code{delta(AT) = TAI-UTC}.

@item iauCal2jd
Gregorian calendar to JD.
@end table

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTcbtdb (double @vari{tcb}, double @varii{tcb}, double * @vari{tdb}, double * @varii{tdb})
Time scale transformation: Barycentric Coordinate Time, TCB, to
Barycentric Dynamical Time, TDB.

Status: canonical.

Given:

@example
tcb1,tcb2  double    TCB as a 2-part Julian Date
@end example

Returned:

@example
tdb1,tdb2  double    TDB as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@code{@vari{tcb} + @varii{tcb}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @vari{tcb}
is the Julian Day Number and @varii{tcb} is the fraction of a day.  The
returned @vari{tdb}, @varii{tdb} follow suit.

@item
The 2006 IAU General Assembly introduced a conventional linear
transformation between TDB and TCB.  This transformation compensates for
the drift between TCB and terrestrial time TT, and keeps TDB
approximately centered on TT.  Because the relationship between TT and
TCB depends on the adopted solar system ephemeris, the degree of
alignment between TDB and TT over long intervals will vary according to
which ephemeris is used.  Former definitions of TDB attempted to avoid
this problem by stipulating that TDB and TT should differ only by
periodic effects.  This is a good description of the nature of the
relationship but eluded precise mathematical formulation.  The
conventional linear relationship adopted in 2006 sidestepped these
difficulties whilst delivering a TDB that in practice was consistent
with values before that date.

@item
TDB is essentially the same as Teph, the time argument for the JPL solar
system ephemerides.
@end enumerate

Reference:

@itemize
@item
IAU 2006 Resolution B3.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTcgtt (double @vari{tcg}, double @varii{tcg}, double * @vari{tt}, double * @varii{tt})
Time scale transformation:  Geocentric Coordinate Time, TCG, to
Terrestrial Time, TT.

Status: canonical.

Given:

@example
tcg1,tcg2  double    TCG as a 2-part Julian Date
@end example

Returned:

@example
tt1,tt2    double    TT as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@item
@code{@vari{tcg} + @varii{tcg}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @vari{tcg}
is the Julian Day Number and @varii{tcg} is the fraction of a day.  The
returned @vari{tt}, @varii{tt} follow suit.
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),.  IERS
Technical Note No. 32, BKG (2004).

@item
IAU 2000 Resolution B1.9.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTdbtcb (double @vari{tdb}, double @varii{tdb}, double * @vari{tcb}, double * @varii{tcb})
Time scale transformation:  Barycentric Dynamical Time, TDB, to
Barycentric Coordinate Time, TCB.

Status: canonical.

Given:

@example
tdb1,tdb2  double    TDB as a 2-part Julian Date
@end example

Returned:

@example
tcb1,tcb2  double    TCB as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@code{@vari{tdb} + @varii{tdb}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @vari{tdb}
is the Julian Day Number and @varii{tdb} is the fraction of a day.  The
returned @vari{tcb}, @varii{tcb} follow suit.

@item
The 2006 IAU General Assembly introduced a conventional linear
transformation between TDB and TCB.  This transformation compensates for
the drift between TCB and terrestrial time TT, and keeps TDB
approximately centered on TT.  Because the relationship between TT and
TCB depends on the adopted solar system ephemeris, the degree of
alignment between TDB and TT over long intervals will vary according to
which ephemeris is used.  Former definitions of TDB attempted to avoid
this problem by stipulating that TDB and TT should differ only by
periodic effects.  This is a good description of the nature of the
relationship but eluded precise mathematical formulation.  The
conventional linear relationship adopted in 2006 sidestepped these
difficulties whilst delivering a TDB that in practice was consistent
with values before that date.

@item
TDB is essentially the same as Teph, the time argument for the JPL solar
system ephemerides.
@end enumerate

Reference:

@itemize
@item
IAU 2006 Resolution B3.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTdbtt (double @vari{tdb}, double @varii{tdb}, double @var{dtr}, double * @vari{tt}, double * @varii{tt} )
Time scale transformation: Barycentric Dynamical Time, TDB, to
Terrestrial Time, TT.

Status: canonical.

Given:

@example
tdb1,tdb2  double    TDB as a 2-part Julian Date
dtr        double    TDB-TT in seconds
@end example

Returned:

@example
tt1,tt2    double    TT as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@code{@vari{tdb} + @varii{tdb}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @vari{tdb}
is the Julian Day Number and tdb2 is the fraction of a day.  The
returned @vari{tt}, @varii{tt} follow suit.

@item
The argument dtr represents the quasi--periodic component of the GR
transformation between TT and TCB.  It is dependent upon the adopted
solar--system ephemeris, and can be obtained by numerical integration,
by interrogating a precomputed time ephemeris or by evaluating a model
such as that implemented in the @sofa{} function @code{iauDtdb}.  The
quantity is dominated by an annual term of @math{1.7} ms amplitude.

@item
TDB is essentially the same as Teph, the time argument for the JPL solar
system ephemerides.
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
IAU 2006 Resolution 3.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTttai (double @vari{tt}, double @varii{tt}, double * @vari{tai}, double * @varii{tai})
Time scale transformation: Terrestrial Time, TT, to International Atomic
Time, TAI.

Status: canonical.

Given:

@example
tt1,tt2    double    TT as a 2-part Julian Date
@end example

Returned:

@example
tai1,tai2  double    TAI as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@code{@vari{tt} + @varii{tt}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @vari{tt} is
the Julian Day Number and @varii{tt} is the fraction of a day.  The
returned @vari{tai}, @varii{tai} follow suit.
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTttcg (double @vari{tt}, double @varii{tt}, double * @vari{tcg}, double * @varii{tcg})
Time scale transformation: Terrestrial Time, TT, to Geocentric
Coordinate Time, TCG.

Status: canonical.

Given:

@example
tt1,tt2    double    TT as a 2-part Julian Date
@end example

Returned:

@example
tcg1,tcg2  double    TCG as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@code{@vari{tt} + @varii{tt}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @vari{tt} is
the Julian Day Number and @varii{tt} is the fraction of a day.  The
returned @vari{tcg}, @varii{tcg} follow suit.
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
IAU 2000 Resolution B1.9.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTttdb (double @vari{tt}, double @varii{tt}, double @var{dtr}, double * @vari{tdb}, double * @varii{tdb})
Time scale transformation:  Terrestrial Time, TT, to Barycentric
Dynamical Time, TDB.

Status: canonical.

Given:

@example
tt1,tt2    double    TT as a 2-part Julian Date
dtr        double    TDB-TT in seconds
@end example

Returned:

@example
tdb1,tdb2  double    TDB as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@code{@vari{tt} + @varii{tt}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @vari{tt} is
the Julian Day Number and @varii{tt} is the fraction of a day.  The
returned @vari{tdb}, @varii{tdb} follow suit.

@item
The argument @var{dtr} represents the quasi--periodic component of the
GR transformation between TT and TCB.  It is dependent upon the adopted
solar--system ephemeris, and can be obtained by numerical integration,
by interrogating a precomputed time ephemeris or by evaluating a model
such as that implemented in the @sofa{} function @code{iauDtdb}.  The
quantity is dominated by an annual term of @math{1.7} ms amplitude.

@item
TDB is essentially the same as Teph, the time argument for the JPL solar
system ephemerides.
@end enumerate

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
IAU 2006 Resolution 3.
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTtut1 (double @vari{tt}, double @varii{tt}, double @var{dt}, double * @var{ut11}, double * @var{ut12})
Time scale transformation: Terrestrial Time, TT, to Universal Time, UT1.

Status: canonical.

Given:

@example
tt1,tt2    double    TT as a 2-part Julian Date
dt         double    TT-UT1 in seconds
@end example

Returned:

@example
ut11,ut12  double    UT1 as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@code{@vari{tt} + @varii{tt}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @vari{tt} is
the Julian Day Number and @varii{tt} is the fraction of a day.  The
returned @var{ut11}, @var{ut12} follow suit.

@item
The argument @var{dt} is classical Delta T.
@end enumerate

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauUt1tai (double @var{ut11}, double @var{ut12}, double @var{dta}, double * @vari{tai}, double * @varii{tai})
Time scale transformation: Universal Time, UT1, to International Atomic
Time, TAI.

Status: canonical.

Given:

@example
ut11,ut12  double    UT1 as a 2-part Julian Date
dta        double    UT1-TAI in seconds
@end example

Returned:

@example
tai1,tai2  double    TAI as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@code{@var{ut11} + @var{ut12}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @var{ut11}
is the Julian Day Number and @var{ut12} is the fraction of a day.  The
returned @vari{tai}, @varii{tai} follow suit.

@item
The argument @var{dta}, i.e. UT1-TAI, is an observed quantity, and is
available from IERS tabulations.
@end enumerate

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauUt1tt (double @var{ut11}, double @var{ut12}, double @var{dt}, double * @vari{tt}, double * @varii{tt})
Time scale transformation: Universal Time, UT1, to Terrestrial Time, TT.

Status: canonical.

Given:

@example
ut11,ut12  double    UT1 as a 2-part Julian Date
dt         double    TT-UT1 in seconds
@end example

Returned:

@example
tt1,tt2    double    TT as a 2-part Julian Date
@end example

Returned (function value):

@example
int       status:  0 = OK
@end example

Notes:

@enumerate
@item
@code{@var{ut11} + @var{ut12}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @var{ut11}
is the Julian Day Number and @var{ut12} is the fraction of a day.  The
returned @vari{tt}, @varii{tt} follow suit.

@item
The argument @var{dt} is classical Delta T.
@end enumerate

Reference:

@itemize
@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauUt1utc (double @var{ut11}, double @var{ut12}, double @var{dut1}, double * @vari{utc}, double * @varii{utc})
Time scale transformation: Universal Time, UT1, to Coordinated Universal
Time, UTC.

Status: canonical.

Given:

@example
ut11,ut12  double   UT1 as a 2-part Julian Date (Note 1)
dut1       double   Delta UT1: UT1-UTC in seconds (Note 2)
@end example

Returned:

@example
utc1,utc2  double   UTC as a 2-part quasi Julian Date (Notes 3,4)
@end example

Returned (function value):

@example
int      status: +1 = dubious year (Note 5)
                  0 = OK
                 -1 = unacceptable date
@end example

Notes:

@enumerate
@item
@code{@var{ut11} + @var{ut12}} is Julian Date, apportioned in any
convenient way between the two arguments, for example where @var{ut11}
is the Julian Day Number and @var{ut12} is the fraction of a day.  The
returned @vari{utc} and @varii{utc} form an analogous pair, except that
a special convention is used, to deal with the problem of leap
seconds---see Note 3.

@item
Delta UT1 can be obtained from tabulations provided by the International
Earth Rotation and Reference Systems Service.  The value changes
abruptly by @math{1} second at a leap second; however, close to a leap
second the algorithm used here is tolerant of the ``wrong'' choice of
value being made.

@item
JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The convention in the present function is
that the returned quasi JD day @code{@vari{UTC} + @varii{utc}}
represents UTC days whether the length is 86399, 86400 or 86401 SI
seconds.

@item
The function @code{iauD2dtf} can be used to transform the UTC quasi-JD
into calendar date and clock time, including UTC leap second handling.

@item
The warning status ``dubious year'' flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See @code{iauDat} for further details.
@end enumerate

Called:

@table @code
@item iauJd2cal
JD to Gregorian calendar.

@item iauDat
@code{delta(AT) = TAI-UTC}.

@item iauCal2jd
Gregorian calendar to JD.
@end table

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauUtctai (double @vari{utc}, double @varii{utc}, double * @vari{tai}, double * @varii{tai})
Time scale transformation: Coordinated Universal Time, UTC, to
International Atomic Time, TAI.

Status: canonical.

Given:

@example
utc1,utc2  double   UTC as a 2-part quasi Julian Date (Notes 1-4)
@end example

Returned:

@example
tai1,tai2  double   TAI as a 2-part Julian Date (Note 5)
@end example

Returned (function value):

@example
int      status: +1 = dubious year (Note 3)
                  0 = OK
                 -1 = unacceptable date
@end example

Notes:

@enumerate
@item
@code{@vari{utc} + @varii{utc}} is quasi Julian Date (see Note 2),
apportioned in any convenient way between the two arguments, for example
where @vari{utc} is the Julian Day Number and @varii{utc} is the
fraction of a day.

@item
JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The convention in the present function is
that the JD day represents UTC days whether the length is 86399, 86400
or 86401 SI seconds.

@item
The warning status ``dubious year'' flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See @code{iauDat} for further details.

@item
The function @code{iauDtf2d} converts from calendar date and time of day
into 2-part Julian Date, and in the case of UTC implements the
leap--second--ambiguity convention described above.

@item
The returned @vari{TAI}, @varii{TAI} are such that their sum is the TAI
Julian Date.
@end enumerate

Called:

@table @code
@item iauJd2cal
JD to Gregorian calendar.

@item iauDat
@code{delta(AT) = TAI-UTC}.

@item iauCal2jd
Gregorian calendar to JD.
@end table

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).
@end itemize
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauUtcut1 (double @vari{utc}, double @varii{utc}, double @var{dut1}, double * @var{ut11}, double * @var{ut12})
Time scale transformation: Coordinated Universal Time, UTC, to Universal
Time, UT1.

Status: canonical.

Given:

@example
utc1,utc2  double   UTC as a 2-part quasi Julian Date (Notes 1-4)
dut1       double   Delta UT1 = UT1-UTC in seconds (Note 5)
@end example

Returned:

@example
ut11,ut12  double   UT1 as a 2-part Julian Date (Note 6)
@end example

Returned (function value):

@example
int      status: +1 = dubious year (Note 7)
                  0 = OK
                 -1 = unacceptable date
@end example

Notes:

@enumerate
@item
@code{@vari{utc} + @varii{utc}} is quasi Julian Date (see Note 2),
apportioned in any convenient way between the two arguments, for example
where @vari{utc} is the Julian Day Number and @varii{utc} is the
fraction of a day.

@item
JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The convention in the present function is
that the JD day represents UTC days whether the length is 86399, 86400
or 86401 SI seconds.

@item
The warning status ``dubious year'' flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See @code{iauDat} for further details.

@item
The function @code{iauDtf2d} converts from calendar date and time of day
into 2-part Julian Date, and in the case of UTC implements the
leap--second--ambiguity convention described above.

@item
Delta UT1 can be obtained from tabulations provided by the International
Earth Rotation and Reference Systems Service.  It It is the caller's
responsibility to supply a DUT argument containing the UT1-UTC value
that matches the given UTC.

@item
The returned @var{ut11}, @var{ut12} are such that their sum is the UT1
Julian Date.

@item
The warning status ``dubious year'' flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See @code{iauDat} for further details.
@end enumerate

Called:

@table @code
@item iauJd2cal
JD to Gregorian calendar.

@item iauDat
@code{delta(AT) = TAI-UTC}.

@item iauUtctai
UTC to TAI.

@item iauTaiut1
TAI to UT1.
@end table

References:

@itemize
@item
McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

@item
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).
@end itemize
@end deftypefun

@c page
@node api vector matrix
@section Vector and matrix functions


@menu
* api AngleOps::                Angle operations.
* api BuildRotations::          Build rotations.
* api CopyExtendExtract::       Copy extend extract.
* api Initialization::          Initialization.
* api MatrixOps::               Matrix operations.
* api MatrixVectorProducts::    Matrix vector products.
* api RotationVectors::         Rotation vectors.
* api SeparationAndAngle::      Separation and angle.
* api SphericalCartesian::      Spherical cartesian.
* api VectorOps::               Vector operations.
@end menu

@c page
@node api AngleOps
@subsection Angle operations


@deftypefun void iauA2af (int @var{ndp}, double @var{angle}, char * @var{sign}, int @var{idmsf}[4])
Decompose radians into degrees, arcminutes, arcseconds, fraction.

Status: vector/matrix support function.

Given:

@example
ndp     int     resolution (Note 1)
angle   double  angle in radians
@end example

Returned:

@example
sign    char    '+' or '-'
idmsf   int[4]  degrees, arcminutes, arcseconds, fraction
@end example

Called:

@table @code
@item iauD2tf
Decompose days to hms.
@end table

Notes:

@enumerate
@item
The argument @var{ndp} is interpreted as follows:

@example
ndp         resolution
 :      ...0000 00 00
-7         1000 00 00
-6          100 00 00
-5           10 00 00
-4            1 00 00
-3            0 10 00
-2            0 01 00
-1            0 00 10
 0            0 00 01
 1            0 00 00.1
 2            0 00 00.01
 3            0 00 00.001
 :            0 00 00.000...
@end example

@item
The largest positive useful value for @var{ndp} is determined by the
size of angle, the format of doubles on the target platform, and the
risk of overflowing @code{idmsf[3]}.  On a typical platform, for angle
up to @code{2pi}, the available floating--point precision might
correspond to @code{ndp=12}.  However, the practical limit is typically
@code{ndp=9}, set by the capacity of a 32-bit int, or @code{ndp=4} if
@code{int} is only 16 bits.

@item
The absolute value of @var{angle} may exceed @code{2pi}.  In cases where
it does not, it is up to the caller to test for and handle the case
where angle is very nearly @code{2pi} and rounds up to @math{360}
degrees, by testing for @code{idmsf[0]=360} and setting
@code{idmsf[0-3]} to zero.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauA2tf (int @var{ndp}, double @var{angle}, char * @var{sign}, int @var{ihmsf}[4])
Decompose radians into hours, minutes, seconds, fraction.

Status: vector/matrix support function.

Given:

@example
ndp     int     resolution (Note 1)
angle   double  angle in radians
@end example

Returned:

@example
sign    char    '+' or '-'
ihmsf   int[4]  hours, minutes, seconds, fraction
@end example

Called:

@table @code
@item iauD2tf
Decompose days to hms.
@end table

Notes:

@enumerate
@item
The argument @var{ndp} is interpreted as follows:

@example
ndp         resolution
 :      ...0000 00 00
-7         1000 00 00
-6          100 00 00
-5           10 00 00
-4            1 00 00
-3            0 10 00
-2            0 01 00
-1            0 00 10
 0            0 00 01
 1            0 00 00.1
 2            0 00 00.01
 3            0 00 00.001
 :            0 00 00.000...
@end example

@item
The largest positive useful value for @var{ndp} is determined by the
size of @var{angle}, the format of doubles on the target platform, and
the risk of overflowing @code{ihmsf[3]}.  On a typical platform, for
@var{angle} up to @code{2pi}, the available floating--point precision
might correspond to @code{ndp=12}.  However, the practical limit is
typically @code{ndp=9}, set by the capacity of a 32-bit int, or
@code{ndp=4} if @code{int} is only 16 bits.

@item
The absolute value of @var{angle} may exceed @code{2pi}.  In cases where
it does not, it is up to the caller to test for and handle the case
where angle is very nearly @code{2pi} and rounds up to @math{24} hours,
by testing for @code{ihmsf[0]=24} and setting @code{ihmsf(0-3)} to zero.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauAf2a (char @var{s}, int @var{ideg}, int @var{iamin}, double @var{asec}, double * @var{rad})
Convert degrees, arcminutes, arcseconds to radians.

Status: support function.

Given:

@example
s         char    sign:  '-' = negative, otherwise positive
ideg      int     degrees
iamin     int     arcminutes
asec      double  arcseconds
@end example

Returned:

@example
rad       double  angle in radians
@end example

Returned (function value):

@example
int     status:  0 = OK
                 1 = ideg outside range 0-359
                 2 = iamin outside range 0-59
                 3 = asec outside range 0-59.999...
@end example

Notes:

@enumerate
@item
The result is computed even if any of the range checks fail.

@item
Negative @var{ideg}, @var{iamin} and/or @var{asec} produce a warning
status, but the absolute value is used in the conversion.

@item
If there are multiple errors, the status value reflects only the first,
the smallest taking precedence.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauAnp (double @var{a})
Normalize angle into the range @code{0 <= @var{a} < 2pi}.

Status: vector/matrix support function.

Given:

@example
a        double     angle (radians)
@end example

Returned (function value):

@example
double     angle in range 0-2pi
@end example
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauAnpm (double @var{a})
Normalize angle into the range @code{-pi <= @var{a} < +pi}.

Status: vector/matrix support function.

Given:

@example
a        double     angle (radians)
@end example

Returned (function value):

@example
double     angle in range +/-pi
@end example
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauD2tf (int @var{ndp}, double @var{days}, char * @var{sign}, int @var{ihmsf}[4])
Decompose days to hours, minutes, seconds, fraction.

Status: vector/matrix support function.

Given:

@example
ndp     int     resolution (Note 1)
days    double  interval in days
@end example

Returned:

@example
sign    char    '+' or '-'
ihmsf   int[4]  hours, minutes, seconds, fraction
@end example

Notes:

@enumerate
@item
The argument @var{ndp} is interpreted as follows:

@example
ndp         resolution
 :      ...0000 00 00
-7         1000 00 00
-6          100 00 00
-5           10 00 00
-4            1 00 00
-3            0 10 00
-2            0 01 00
-1            0 00 10
 0            0 00 01
 1            0 00 00.1
 2            0 00 00.01
 3            0 00 00.001
 :            0 00 00.000...
@end example

@item
The largest positive useful value for @var{ndp} is determined by the
size of days, the format of double on the target platform, and the risk
of overflowing @code{ihmsf[3]}.  On a typical platform, for days up to
@math{1.0}, the available floating--point precision might correspond to
@code{@var{ndp} = 12}.  However, the practical limit is typically
@code{@var{ndp} = 9}, set by the capacity of a 32-bit int, or
@code{@var{ndp} = 4} if int is only 16 bits.

@item
The absolute value of days may exceed @math{1.0}.  In cases where it
does not, it is up to the caller to test for and handle the case where
days is very nearly @math{1.0} and rounds up to 24 hours, by testing for
@code{@var{ihmsf}[0] = 24} and setting @code{@var{ihmsf}[0-3]} to zero.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTf2a (char @var{s}, int @var{ihour}, int @var{imin}, double @var{sec}, double * @var{rad})
Convert hours, minutes, seconds to radians.

Status: support function.

Given:

@example
s         char    sign:  '-' = negative, otherwise positive
ihour     int     hours
imin      int     minutes
sec       double  seconds
@end example

Returned:

@example
rad       double  angle in radians
@end example

Returned (function value):

@example
int     status:  0 = OK
                 1 = ihour outside range 0-23
                 2 = imin outside range 0-59
                 3 = sec outside range 0-59.999...
@end example

Notes:

@enumerate
@item
The result is computed even if any of the range checks fail.

@item
Negative @var{ihour}, @var{imin} and/or @var{sec} produce a warning
status, but the absolute value is used in the conversion.

@item
If there are multiple errors, the status value reflects only the first,
the smallest taking precedence.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun int iauTf2d (char @var{s}, int @var{ihour}, int @var{imin}, double @var{sec}, double * @var{days})
Convert hours, minutes, seconds to days.

Status: support function.

Given:

@example
s         char    sign:  '-' = negative, otherwise positive
ihour     int     hours
imin      int     minutes
sec       double  seconds
@end example

Returned:

@example
days      double  interval in days
@end example

Returned (function value):

@example
int     status:  0 = OK
                 1 = ihour outside range 0-23
                 2 = imin outside range 0-59
                 3 = sec outside range 0-59.999...
@end example

Notes:

@enumerate
@item
The result is computed even if any of the range checks fail.

@item
Negative @var{ihour}, @var{imin} and/or @var{sec} produce a warning
status, but the absolute value is used in the conversion.

@item
If there are multiple errors, the status value reflects only the first,
the smallest taking precedence.
@end enumerate
@end deftypefun

@c page
@node api BuildRotations
@subsection Build rotations


@deftypefun void iauRx (double @var{phi}, double @var{r}[3][3])
Rotate an @code{r}-matrix about the @math{X}-axis.

Status: vector/matrix support function.

Given:

@example
phi    double          angle (radians)
@end example

Given and returned:

@example
r      double[3][3]    r-matrix, rotated
@end example

Notes:

@enumerate
@item
Calling this function with positive phi incorporates in the supplied
@code{r}-matrix @var{r} an additional rotation, about the @math{X}-axis,
anticlockwise as seen looking towards the origin from positive @var{x}.

@item
The additional rotation can be represented by this matrix:

@example
(  1       0           0      )
(  0   +cos(phi)   +sin(phi)  )
(  0   -sin(phi)   +cos(phi)  )
@end example
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauRy (double @var{theta}, double @var{r}[3][3])
Rotate an @code{r}-matrix about the @math{Y}-axis.

Status: vector/matrix support function.

Given:

@example
theta  double          angle (radians)
@end example

Given and returned:

@example
r      double[3][3]    r-matrix, rotated
@end example

Notes:

@enumerate
@item
Calling this function with positive theta incorporates in the supplied
@code{r}-matrix @var{r} an additional rotation, about the @math{Y}-axis,
anticlockwise as seen looking towards the origin from positive @math{Y}.

@item
The additional rotation can be represented by this matrix:

@example
(  +cos(theta)     0      -sin(theta)  )
(      0           1          0        )
(  +sin(theta)     0      +cos(theta)  )
@end example
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauRz (double @var{psi}, double @var{r}[3][3])
Rotate an @code{r}-matrix about the @math{Z}-axis.

Status: vector/matrix support function.

Given:

@example
psi    double          angle (radians)
@end example

Given and returned:

@example
r      double[3][3]    r-matrix, rotated
@end example

Notes:

@enumerate
@item
Calling this function with positive psi incorporates in the supplied
@code{r}-matrix @var{r} an additional rotation, about the @math{Z}-axis,
anticlockwise as seen looking towards the origin from positive @math{Z}.

@item
The additional rotation can be represented by this matrix:

@example
(  +cos(psi)   +sin(psi)    0  )
(  -sin(psi)   +cos(psi)    0  )
(      0           0        1  )
@end example
@end enumerate
@end deftypefun

@c page
@node api CopyExtendExtract
@subsection Copy extend extract


@deftypefun void iauCp (double @var{p}[3], double @var{c}[3])
Copy a @code{p}-vector.

Status: vector/matrix support function.

Given:

@example
p        double[3]     p-vector to be copied
@end example

Returned:

@example
c        double[3]     copy
@end example
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauCpv (double @var{pv}[2][3], double @var{c}[2][3])
Copy a position/velocity vector.

Status: vector/matrix support function.

Given:

@example
pv     double[2][3]    position/velocity vector to be copied
@end example

Returned:

@example
c      double[2][3]    copy
@end example

Called:

@table @code
@item iauCp
Copy @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauCr (double @var{r}[3][3], double @var{c}[3][3])
Copy an @code{r}-matrix.

Status: vector/matrix support function.

Given:

@example
r        double[3][3]    r-matrix to be copied
@end example

Returned:

@example
char[]     double[3][3]    copy
@end example

Called:

@table @code
@item iauCp
Copy @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauP2pv (double @var{p}[3], double @var{pv}[2][3])
Extend a @code{p}-vector to a @code{pv}-vector by appending a zero
velocity.

Status: vector/matrix support function.

Given:

@example
p        double[3]       p-vector
@end example

Returned:

@example
pv       double[2][3]    pv-vector
@end example

Called:

@table @code
@item iauCp
Copy @code{p}-vector.

@item iauZp
Zero @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPv2p (double @var{pv}[2][3], double @var{p}[3])
Discard velocity component of a @var{pv}-vector.

Status: vector/matrix support function.

Given:

@example
pv      double[2][3]     pv-vector
@end example

Returned:

@example
p       double[3]        p-vector
@end example

Called:

@table @code
@item iauCp
Copy @code{p}-vector.
@end table
@end deftypefun

@c page
@node api Initialization
@subsection Initialization


@deftypefun void iauIr (double @var{r}[3][3])
Initialize an @code{r}-matrix to the identity matrix.

Status: vector/matrix support function.

Returned:

@example
r       double[3][3]    r-matrix
@end example
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauZp (double @var{p}[3])
Zero a @code{p}-vector.

Status: vector/matrix support function.

Returned:

@example
p        double[3]      p-vector
@end example
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauZpv (double @var{pv}[2][3])
Zero a @code{pv}-vector.

Status: vector/matrix support function.

Returned:

@example
pv       double[2][3]      pv-vector
@end example

Called:

@table @code
@item iauZp
Zero @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauZr (double @var{r}[3][3])
Initialize an @code{r}-matrix to the null matrix.

Status: vector/matrix support function.

Returned:

@example
r        double[3][3]    r-matrix
@end example
@end deftypefun

@c page
@node api MatrixOps
@subsection Matrix operations


@deftypefun void iauRxr (double @var{a}[3][3], double @var{b}[3][3], double @var{atb}[3][3])
Multiply two @code{r}-matrices.

Status: vector/matrix support function.

Given:

@example
a        double[3][3]    first r-matrix
b        double[3][3]    second r-matrix
@end example

Returned:

@example
atb      double[3][3]    a * b
@end example

Notes:

@enumerate
@item
It is permissible to re-use the same array for any of the arguments.
@end enumerate

Called:

@table @code
@item iauCr
Copy @code{r}-matrix.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauTr (double @var{r}[3][3], double @var{rt}[3][3])
Transpose an @code{r}-matrix.

Status: vector/matrix support function.

Given:

@example
r        double[3][3]    r-matrix
@end example

Returned:

@example
rt       double[3][3]    transpose
@end example

Notes:

@enumerate
@item
It is permissible for @var{r} and @var{rt} to be the same array.
@end enumerate

Called:

@table @code
@item iauCr
Copy @code{r}-matrix.
@end table
@end deftypefun

@c page
@node api MatrixVectorProducts
@subsection Matrix vector products


@deftypefun void iauRxp (double @var{r}[3][3], double @var{p}[3], double @var{rp}[3])
Multiply a @code{p}-vector by an @code{r}-matrix.

Status: vector/matrix support function.

Given:

@example
r        double[3][3]    r-matrix
p        double[3]       p-vector
@end example

Returned:

@example
rp       double[3]       r * p
@end example

Notes:

@enumerate
It is permissible for p and rp to be the same array.
@end enumerate

Called:

@table @code
@item iauCp
Copy @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauRxpv (double @var{r}[3][3], double @var{pv}[2][3], double @var{rpv}[2][3])
Multiply a @var{pv}-vector by an @code{r}-matrix.

Status: vector/matrix support function.

Given:

@example
r        double[3][3]    r-matrix
pv       double[2][3]    pv-vector
@end example

Returned:

@example
rpv      double[2][3]    r * pv
@end example

Notes:

@enumerate
@item
It is permissible for @var{pv} and @var{rpv} to be the same array.
@end enumerate

Called:

@table @code
@item iauRxp
Product of @code{r}-matrix and @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauTrxp (double @var{r}[3][3], double @var{p}[3], double @var{trp}[3])
Multiply a @code{p}-vector by the transpose of an @code{r}-matrix.

Status: vector/matrix support function.

Given:

@example
r        double[3][3]   r-matrix
p        double[3]      p-vector
@end example

Returned:

@example
trp      double[3]      r * p
@end example

Notes:

@enumerate
@item
It is permissible for @var{p} and @var{trp} to be the same array.
@end enumerate

Called:

@table @code
@item iauTr
Transpose @code{r}-matrix.

@item iauRxp
Product of @code{r}-matrix and @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauTrxpv (double @var{r}[3][3], double @var{pv}[2][3], double @var{trpv}[2][3])
Multiply a @var{pv}-vector by the transpose of an @code{r}-matrix.

Status: vector/matrix support function.

Given:

@example
r        double[3][3]    r-matrix
pv       double[2][3]    pv-vector
@end example

Returned:

@example
trpv     double[2][3]    r * pv
@end example

Notes:

@enumerate
@item
It is permissible for @var{pv} and @var{trpv} to be the same array.
@end enumerate

Called:

@table @code
@item iauTr
Transpose @code{r}-matrix.

@item iauRxpv
Product of @code{r}-matrix and @var{pv}-vector.
@end table
@end deftypefun

@c page
@node api RotationVectors
@subsection Rotation vectors


@deftypefun void iauRm2v (double @var{r}[3][3], double @var{w}[3])
Express an @code{r}-matrix as an @code{r}-vector.

Status: vector/matrix support function.

Given:

@example
r        double[3][3]    rotation matrix
@end example

Returned:

@example
w        double[3]       rotation vector (Note 1)
@end example

Notes:

@enumerate
@item
A rotation matrix describes a rotation through some angle about some
arbitrary axis called the Euler axis.  The ``rotation vector'' returned
by this function has the same direction as the Euler axis, and its
magnitude is the angle in radians.  (The magnitude and direction can be
separated by means of the function @code{iauPn}.)

@item
If @var{r} is null, so is the result.  If @var{r} is not a rotation
matrix the result is undefined; @var{r} must be proper (i.e. have a
positive determinant) and real orthogonal (inverse = transpose).

@item
The reference frame rotates clockwise as seen looking along the rotation
vector from the origin.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauRv2m (double @var{w}[3], double @var{r}[3][3])
Form the @code{r}-matrix corresponding to a given @code{r}-vector.

Status: vector/matrix support function.

Given:

@example
w        double[3]      rotation vector (Note 1)
@end example

Returned:

@example
r        double[3][3]    rotation matrix
@end example

Notes:

@enumerate
@item
A rotation matrix describes a rotation through some angle about some
arbitrary axis called the Euler axis.  The ``rotation vector'' supplied
to This function has the same direction as the Euler axis, and its
magnitude is the angle in radians.

@item
If @var{w} is null, the unit matrix is returned.

@item
The reference frame rotates clockwise as seen looking along the rotation
vector from the origin.
@end enumerate
@end deftypefun

@c page
@node api SeparationAndAngle
@subsection Separation and angle


@deftypefun double iauPap (double @var{a}[3], double @var{b}[3])
Position--angle from two @code{p}-vectors.

Status: vector/matrix support function.

Given:

@example
a      double[3]  direction of reference point
b      double[3]  direction of point whose PA is required
@end example

Returned (function value):

@example
       double     position angle of b with respect to a (radians)
@end example

Notes:

@enumerate
@item
The result is the position angle, in radians, of direction @var{b} with
respect to direction @var{a}.  It is in the range -pi to +pi.  The sense
is such that if @var{b} is a small distance ``north'' of @var{a} the
position angle is approximately zero, and if @var{b} is a small distance
``east'' of @var{a} the position angle is approximately +pi/2.

@item
The vectors @var{a} and @var{b} need not be of unit length.

@item
Zero is returned if the two directions are the same or if either vector
is null.

@item
If vector @var{a} is at a pole, the result is ill--defined.
@end enumerate

Called:

@table @code
@item iauPn
Decompose @code{p}-vector into modulus and direction.

@item iauPm
Modulus of @code{p}-vector.

@item iauPxp
Vector product of two @code{p}-vectors.

@item iauPmp
@code{p}-vector minus @code{p}-vector.

@item iauPdp
Scalar product of two @code{p}-vectors.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauPas (double @var{al}, double @var{ap}, double @var{bl}, double @var{bp})
Position--angle from spherical coordinates.

Status: vector/matrix support function.

Given:

@example
al     double     longitude of point A (e.g. RA) in radians
ap     double     latitude of point A (e.g. Dec) in radians
bl     double     longitude of point B
bp     double     latitude of point B
@end example

Returned (function value):

@example
       double     position angle of B with respect to A
@end example

Notes:

@enumerate
@item
The result is the bearing (position angle), in radians, of point B with
respect to point A.  It is in the range -pi to +pi.  The sense is such
that if B is a small distance ``east'' of point A, the bearing is
approximately +pi/2.

@item
Zero is returned if the two points are coincident.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauSepp (double @var{a}[3], double @var{b}[3])
Angular separation between two @code{p}-vectors.

Status: vector/matrix support function.

Given:

@example
a      double[3]    first p-vector (not necessarily unit length)
b      double[3]    second p-vector (not necessarily unit length)
@end example

Returned (function value):

@example
       double       angular separation (radians, always positive)
@end example

Notes:

@enumerate
@item
If either vector is null, a zero result is returned.

@item
The angular separation is most simply formulated in terms of scalar
product.  However, this gives poor accuracy for angles near zero and
@math{\pi}.  The present algorithm uses both cross product and dot
product, to deliver full accuracy whatever the size of the angle.
@end enumerate

Called:

@table @code
@item iauPxp
Vector product of two @code{p}-vectors.

@item iauPm
Modulus of @code{p}-vector.

@item iauPdp
Scalar product of two @code{p}-vectors.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauSeps (double @var{al}, double @var{ap}, double @var{bl}, double @var{bp})
Angular separation between two sets of spherical coordinates.

Status: vector/matrix support function.

Given:

@example
al     double       first longitude (radians)
ap     double       first latitude (radians)
bl     double       second longitude (radians)
bp     double       second latitude (radians)
@end example

Returned (function value):

@example
       double       angular separation (radians)
@end example

Called:

@table @code
@item iauS2c
Spherical coordinates to unit vector.

@item iauSepp
Angular separation between two @code{p}-vectors.
@end table
@end deftypefun

@c page
@node api SphericalCartesian
@subsection Spherical cartesian


@deftypefun void iauC2s (double @var{p}[3], double * @var{theta}, double * @var{phi})
@code{p}-vector to spherical coordinates.

Status: vector/matrix support function.

Given:

@example
p      double[3]    p-vector
@end example

Returned:

@table @code
theta  double       longitude angle (radians)
phi    double       latitude angle (radians)
@end table

Notes:

@enumerate
@item
The vector @var{p} can have any magnitude; only its direction is used.

@item
If @var{p} is null, zero @var{theta} and @var{phi} are returned.

@item
At either pole, zero @var{theta} is returned.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauP2s (double @var{p}[3], double * @var{theta}, double * @var{phi}, double * @var{r})
@code{p}-vector to spherical polar coordinates.

Status: vector/matrix support function.

Given:

@example
p        double[3]    p-vector
@end example

Returned:

@example
theta    double       longitude angle (radians)
phi      double       latitude angle (radians)
r        double       radial distance
@end example

Notes:

@enumerate
@item
If @var{p} is null, zero @var{theta}, @var{phi} and @var{r} are
returned.

@item
At either pole, zero @var{theta} is returned.
@end enumerate

Called:

@table @code
@item iauC2s
@code{p}-vector to spherical.

@item iauPm
Modulus of @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPv2s (double @var{pv}[2][3], double * @var{theta}, double * @var{phi}, double * @var{r}, double * @var{td}, double * @var{pd}, double * @var{rd})
Convert position/velocity from Cartesian to spherical coordinates.

Status: vector/matrix support function.

Given:

@example
pv       double[2][3]  pv-vector
@end example

Returned:

@example
theta    double        longitude angle (radians)
phi      double        latitude angle (radians)
r        double        radial distance
td       double        rate of change of theta
pd       double        rate of change of phi
rd       double        rate of change of r
@end example

Notes:

@enumerate
@item
If the position part of @var{pv} is null, @var{theta}, @var{phi},
@var{td} and @var{pd} are indeterminate.  This is handled by
extrapolating the position through unit time by using the velocity part
of @var{pv}.  This moves the origin without changing the direction of
the velocity component.  If the position and velocity components of pv
are both null, zeroes are returned for all six results.

@item
If the position is a pole, @var{theta}, @var{td} and @var{pd} are
indeterminate.  In such cases zeroes are returned for all three.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauS2c (double @var{theta}, double @var{phi}, double @var{c}[3])
Convert spherical coordinates to Cartesian.

Status: vector/matrix support function.

Given:

@example
theta    double       longitude angle (radians)
phi      double       latitude angle (radians)
@end example

Returned:

@example
c        double[3]    direction cosines
@end example
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauS2p (double @var{theta}, double @var{phi}, double @var{r}, double @var{p}[3])
Convert spherical polar coordinates to @code{p}-vector.

Status: vector/matrix support function.

Given:

@example
theta   double       longitude angle (radians)
phi     double       latitude angle (radians)
r       double       radial distance
@end example

Returned:

@example
p       double[3]    Cartesian coordinates
@end example

Called:

@table @code
@item iauS2c
Spherical coordinates to unit vector.

@item iauSxp
Multiply @code{p}-vector by scalar.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauS2pv (double @var{theta}, double @var{phi}, double @var{r}, double @var{td}, double @var{pd}, double @var{rd}, double @var{pv}[2][3])
Convert position/velocity from spherical to Cartesian coordinates.

Status: vector/matrix support function.

Given:

@example
theta    double          longitude angle (radians)
phi      double          latitude angle (radians)
r        double          radial distance
td       double          rate of change of theta
pd       double          rate of change of phi
rd       double          rate of change of r
@end example

Returned:

@example
pv       double[2][3]    pv-vector
@end example
@end deftypefun

@c page
@node api VectorOps
@subsection Vector operations


@deftypefun double iauPdp (double @var{a}[3], double @var{b}[3])
@code{p}-vector inner (=scalar=dot) product.

Status: vector/matrix support function.

Given:

@example
a      double[3]     first p-vector
b      double[3]     second p-vector
@end example

Returned (function value):

@example
       double        a . b
@end example
@end deftypefun

@c ------------------------------------------------------------

@deftypefun double iauPm (double @var{p}[3])
Modulus of @code{p}-vector.

Status: vector/matrix support function.

Given:

@example
p      double[3]     p-vector
@end example

Returned (function value):

@example
       double        modulus
@end example
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPmp (double @var{a}[3], double @var{b}[3], double @var{amb}[3])
@code{p}-vector subtraction.

Status: vector/matrix support function.

Given:

@example
a        double[3]      first p-vector
b        double[3]      second p-vector
@end example

Returned:

@example
amb      double[3]      a - b
@end example

Notes:

@enumerate
@item
It is permissible to re-use the same array for any of the arguments.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPn (double @var{p}[3], double * @var{r}, double @var{u}[3])
Convert a @code{p}-vector into modulus and unit vector.

Status: vector/matrix support function.

Given:

@example
p        double[3]      p-vector
@end example

Returned:

@example
r        double         modulus
u        double[3]      unit vector
@end example

Notes:

@enumerate
@item
If @var{p} is null, the result is null.  Otherwise the result is a unit
vector.

@item
It is permissible to re-use the same array for any of the arguments.
@end enumerate

Called:

@table @code
@item iauPm
Modulus of @code{p}-vector.

@item iauZp
Zero @code{p}-vector.

@item iauSxp
Multiply @code{p}-vector by scalar.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPpp (double @var{a}[3], double @var{b}[3], double @var{apb}[3])
@code{p}-vector addition.

Status: vector/matrix support function.

Given:

@example
   a        double[3]      first p-vector
   b        double[3]      second p-vector
@end example

Returned:

@example
   apb      double[3]      a + b
@end example

Notes:

@enumerate
It is permissible to re-use the same array for any of the arguments.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPpsp (double @var{a}[3], double @var{s}, double @var{b}[3], double @var{apsb}[3])
@code{p}-vector plus scaled @code{p}-vector.

Status: vector/matrix support function.

Given:

@example
a      double[3]     first p-vector
s      double        scalar (multiplier for b)
b      double[3]     second p-vector
@end example

Returned:

@example
apsb   double[3]     a + s*b
@end example

Notes:

@enumerate
@item
It is permissible for any of @var{a}, @var{b} and @var{apsb} to be the
same array.
@end enumerate

Called:

@table @code
@item iauSxp
Multiply @code{p}-vector by scalar.

@item iauPpp
@code{p}-vector plus @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPvdpv (double @var{a}[2][3], double @var{b}[2][3], double @var{adb}[2])
Inner (=scalar=dot) product of two @var{pv}-vectors.

Status: vector/matrix support function.

Given:

@example
a        double[2][3]      first pv-vector
b        double[2][3]      second pv-vector
@end example

Returned:

@example
adb      double[2]         a . b (see note)
@end example

Notes:

@enumerate
@item
If the position and velocity components of the two @var{pv}-vectors are
@code{(ap, av)} and @code{(bp, bv)}, the result, @code{@var{a} *
@var{b}}, is the pair of numbers @code{(ap * bp, ap * bv + av bp)}.  The
two numbers are the dot--product of the two @code{p}-vectors and its
derivative.
@end enumerate

Called:

@table @code
@item iauPdp
Scalar product of two @code{p}-vectors.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPvm (double @var{pv}[2][3], double * @var{r}, double * @var{s})
Modulus of @var{pv}-vector.

Status: vector/matrix support function.

Given:

@example
pv     double[2][3]   pv-vector
@end example

Returned:

@example
r      double         modulus of position component
s      double         modulus of velocity component
@end example

Called:

@table @code
@item iauPm
Modulus of @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPvmpv (double @var{a}[2][3], double @var{b}[2][3], double @var{amb}[2][3])
Subtract one @var{pv}-vector from another.

Status: vector/matrix support function.

Given:

@example
a       double[2][3]      first pv-vector
b       double[2][3]      second pv-vector
@end example

Returned:

@example
amb     double[2][3]      a - b
@end example

Notes:

@enumerate
@item
It is permissible to re-use the same array for any of the arguments.
@end enumerate

Called:

@table @code
@item iauPmp
@code{p}-vector minus @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPvppv (double @var{a}[2][3], double @var{b}[2][3], double @var{apb}[2][3])
Add one @var{pv}-vector to another.

Status: vector/matrix support function.

Given:

@example
a        double[2][3]      first pv-vector
b        double[2][3]      second pv-vector
@end example

Returned:

@example
apb      double[2][3]      a + b
@end example

Notes:

@enumerate
@item
It is permissible to re-use the same array for any of the arguments.
@end enumerate

Called:

@table @code
@item iauPpp
@code{p}-vector plus @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPvu (double @var{dt}, double @var{pv}[2][3], double @var{upv}[2][3])
Update a @var{pv}-vector.

Status: vector/matrix support function.

Given:

@example
dt       double           time interval
pv       double[2][3]     pv-vector
@end example

Returned:

@example
upv      double[2][3]     p updated, v unchanged
@end example

Notes:

@enumerate
@item
``Update'' means ``refer the position component of the vector to a new
date @var{dt} time units from the existing date''.

@item
The time units of @var{dt} must match those of the velocity.

@item
It is permissible for @var{pv} and @var{upv} to be the same array.
@end enumerate

Called:

@table @code
@item iauPpsp
@code{p}-vector plus scaled @code{p}-vector.

@item iauCp
Copy @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPvup (double @var{dt}, double @var{pv}[2][3], double @var{p}[3])
Update a @var{pv}-vector, discarding the velocity component.

Status: vector/matrix support function.

Given:

@example
dt       double            time interval
pv       double[2][3]      pv-vector
@end example

Returned:

@example
p        double[3]         p-vector
@end example

Notes:

@enumerate
@item
``Update'' means ``refer the position component of the vector to a new
date @var{dt} time units from the existing date''.

@item
The time units of @var{dt} must match those of the velocity.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPvxpv (double @var{a}[2][3], double @var{b}[2][3], double @var{axb}[2][3])
Outer (=vector=cross) product of two @var{pv}-vectors.

Status: vector/matrix support function.

Given:

@example
a        double[2][3]      first pv-vector
b        double[2][3]      second pv-vector
@end example

Returned:

@example
axb      double[2][3]      a x b
@end example

Notes:

@enumerate
@item
If the position and velocity components of the two @var{pv}-vectors are
@code{(ap, av)} and @code{(bp, bv)}, the result, @code{a x b}, is the
pair of vectors @code{(ap x bp, ap x bv + av x bp)}.  The two vectors
are the cross--product of the two @code{p}-vectors and its derivative.

@item
It is permissible to re-use the same array for any of the arguments.
@end enumerate

Called:

@table @code
@item iauCpv
Copy @code{pv}-vector.

@item iauPxp
Vector product of two @code{p}-vectors.

@item iauPpp
@code{p}-vector plus @code{p}-vector.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauPxp (double @var{a}[3], double @var{b}[3], double @var{axb}[3])
@code{p}-vector outer (=vector=cross) product.

Status: vector/matrix support function.

Given:

@example
a        double[3]      first p-vector
b        double[3]      second p-vector
@end example

Returned:

@example
axb      double[3]      a x b
@end example

Notes:

@enumerate
@item
It is permissible to re-use the same array for any of the arguments.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauS2xpv (double @var{s1}, double @var{s2}, double @var{pv}[2][3], double @var{spv}[2][3])
Multiply a @var{pv}-vector by two scalars.

Status: vector/matrix support function.

Given:

@example
s1     double         scalar to multiply position component by
s2     double         scalar to multiply velocity component by
pv     double[2][3]   pv-vector
@end example

Returned:

@example
spv    double[2][3]   pv-vector: p scaled by s1, v scaled by s2
@end example

Notes:

@enumerate
@item
It is permissible for @var{pv} and @var{spv} to be the same array.
@end enumerate

Called:

@table @code
@item iauSxp
Multiply @code{p}-vector by scalar.
@end table
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauSxp (double @var{s}, double @var{p}[3], double @var{sp}[3])
Multiply a @code{p}-vector by a scalar.

Status: vector/matrix support function.

Given:

@example
s      double        scalar
p      double[3]     p-vector
@end example

Returned:

@example
sp     double[3]     s * p
@end example

Notes:

@enumerate
@item
It is permissible for @var{p} and @var{sp} to be the same array.
@end enumerate
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void iauSxpv (double s, double @var{pv}[2][3], double @var{spv}[2][3])
Multiply a @var{pv}-vector by a scalar.

Status: vector/matrix support function.

Given:

@example
s       double          scalar
pv      double[2][3]    pv-vector
@end example

Returned:

@example
spv     double[2][3]    s * pv
@end example

Notes:

@enumerate
@item
It is permissible for @var{pv} and @var{psv} to be the same array.
@end enumerate

Called:

@table @code
@item iauS2xpv
Multiply @var{pv}-vector by two scalars.
@end table
@end deftypefun

@c page
@node api consts fortran
@section Fortran language constants


These must be used exactly as presented below.

@table @asis
@item Pi
@example
DOUBLE PRECISION DPI
PARAMETER ( DPI = 3.141592653589793238462643D0 )
@end example

@item 2Pi
@example
DOUBLE PRECISION D2PI
PARAMETER ( D2PI = 6.283185307179586476925287D0 )
@end example

@item Radians to hours
@example
DOUBLE PRECISION DR2H
PARAMETER ( DR2H = 3.819718634205488058453210D0 )
@end example

@item Radians to seconds
@example
DOUBLE PRECISION DR2S
PARAMETER ( DR2S = 13750.98708313975701043156D0 )
@end example

@item Radians to degrees
@example
DOUBLE PRECISION DR2D
PARAMETER ( DR2D = 57.29577951308232087679815D0 )
@end example

@item Radians to arc seconds
@example
DOUBLE PRECISION DR2AS
PARAMETER ( DR2AS = 206264.8062470963551564734D0 )
@end example

@item Hours to radians
@example
DOUBLE PRECISION DH2R
PARAMETER ( DH2R = 0.2617993877991494365385536D0 )
@end example

@item Seconds to radians
@example
DOUBLE PRECISION DS2R
PARAMETER ( DS2R = 7.272205216643039903848712D-5 )
@end example

@item Degrees to radians
@example
DOUBLE PRECISION DD2R
PARAMETER ( DD2R = 1.745329251994329576923691D-2 )
@end example

@item Arc seconds to radians
@example
DOUBLE PRECISION DAS2R
PARAMETER ( DAS2R = 4.848136811095359935899141D-6 )
@end example
@end table

@c page
@node api consts c
@section C language constants


The constants used by the C version of @sofa{} are defined in the header
file @file{sofam.h}.


@defvr Constant DPI
Pi.
@end defvr


@defvr Constant D2PI
Twice pi.
@end defvr


@defvr Constant DD2R
Degrees to radians.
@end defvr


@defvr Constant DR2AS
Radians to arcseconds.
@end defvr


@defvr Constant DAS2R
Arcseconds to radians.
@end defvr


@defvr Constant DS2R
Seconds of time to radians.
@end defvr


@defvr Constant TURNAS
Arcseconds in a full circle.
@end defvr


@defvr Constant DMAS2R
Milliarcseconds to radians.
@end defvr


@defvr Constant DTY
Length of tropical year B1900 (days).
@end defvr


@defvr Constant DAYSEC
Seconds per day..
@end defvr


@defvr Constant DJY
Days per Julian year.
@end defvr


@defvr Constant DJC
Days per Julian century.
@end defvr


@defvr Constant DJM
Days per Julian millennium.
@end defvr


@defvr Constant DJ00
Reference epoch (J2000.0), Julian Date.
@end defvr


@defvr Constant DJM0
Julian Date of Modified Julian Date zero.
@end defvr


@defvr Constant DJM00
Reference epoch (J2000.0), Modified Julian Date.
@end defvr


@defvr Constant DJM77
1977 Jan 1.0 as MJD.
@end defvr


@defvr Constant TTMTAI
TT minus TAI (s).
@end defvr


@defvr Constant DAU
AU (m).
@end defvr


@defvr Constant DC
Speed of light (AU per day).
@end defvr


@defvr Constant ELG
L_G = 1 - d(TT)/d(TCG).
@end defvr


@defvr Constant ELB
@defvrx constant TDB0
@code{L_B = 1 - d(TDB)/d(TCB)} and TDB (s) at TAI 1977/1/1.0.
@end defvr


@defvr Constant WGS84
@defvrx Constant GRS80
@defvrx Constant WGS72
Reference ellipsoids.
@end defvr

@c ------------------------------------------------------------

@deftypefn {Preprocessor Macro} double dint (double @var{A})
Truncate to nearest whole number towards zero (double).
@end deftypefn


@deftypefn {Preprocessor Macro} double dnint (double @var{A})
Round to nearest whole number.
@end deftypefn


@deftypefn {Preprocessor Macro} double dsign (double @var{A}, double @var{B})
Magnitude of @var{A} with sign of @var{B}.
@end deftypefn

@c page
@node board
@appendix @iau{} Standards of Fundamental Astronomy Board


Current membership:

@table @asis
@item John Bangert
United States Naval Observatory.

@item Steven Bell
Her Majesty's Nautical Almanac Office.

@item Mark Calabretta
Australia Telescope National Facility.

@item Nicole Capitaine
Paris Observatory.

@item William Folkner
Jet Propulsion Laboratory.

@item George Hobbs
Australia Telescope National Facility.

@item Catherine Hohenkerk
Her Majesty's Nautical Almanac Office (Chair).

@item Wen-Jing Jin
Shanghai Observatory.

@item Brian Luzum
United States Naval Observatory (@acronym{IERS}).

@item Zinovy Malkin
Pulkovo Observatory, St Petersburg.

@item Jeffrey Percival
University of Wisconsin.

@item Patrick Wallace
Rutherford Appleton Laboratory.
@end table

Past members:

@table @asis
@item Wim Brouw
University of Groningen.

@item Anne-Marie Gontier
Paris Observatory.

@item George Kaplan
United States Naval Observatory.

@item Dennis McCarthy
United States Naval Observatory.

@item Skip Newhall
Jet Propulsion Laboratory.
@end table

The e-mail for the Board chair is @email{Catherine.Hohenkerk@@ukho.gov.uk}.

@c page
@node license
@appendix Package license


The copyright of the @sofa{} Software belongs to the Standards Of
Fundamental Astronomy Board of the International Astronomical Union.

@c ------------------------------------------------------------

@appendixsec @sofa{} Software License

By using this software you accept the following six terms and conditions
which apply to its use.

@enumerate
@item
The Software is owned by the @iau{} @sofa{} Board (``@sofa{}'').

@item
Permission is granted to anyone to use the @sofa{} software for any
purpose, including commercial applications, free of charge and without
payment of royalties, subject to the conditions and restrictions listed
below.

@item
You (the user) may copy and distribute @sofa{} source code to others,
and use and adapt its code and algorithms in your own software, on a
world--wide, royalty--free basis.  That portion of your distribution
that does not consist of intact and unchanged copies of @sofa{} source
code files is a ``derived work'' that must comply with the following
requirements:

@itemize a
@item
Your work shall be marked or carry a statement that it (i) uses routines
and computations derived by you from software provided by @sofa{} under
license to you; and (ii) does not itself constitute software provided by
and/or endorsed by @sofa{}.

@item
The source code of your derived work must contain descriptions of how
the derived work is based upon, contains and/or differs from the
original @sofa{} software.

@item
The names of all routines in your derived work shall not include the
prefix @code{iau} or @code{sofa} or trivial modifications thereof such
as changes of case.

@item
The origin of the @sofa{} components of your derived work must not be
misrepresented; you must not claim that you wrote the original software,
nor file a patent application for @sofa{} software or algorithms
embedded in the @sofa{} software.

@item
These requirements must be reproduced intact in any source distribution
and shall apply to anyone to whom you have granted a further right to
modify the source code of your derived work.
@end itemize

Note that, as originally distributed, the @sofa{} software is intended
to be a definitive implementation of the @iau{} standards, and
consequently third--party modifications are discouraged.  All
variations, no matter how minor, must be explicitly marked as such, as
explained above.

@item
You shall not cause the @sofa{} software to be brought into disrepute,
either by misuse, or use for inappropriate tasks, or by inappropriate
modification.

@item
The @sofa{} software is provided ``as is'' and @sofa{} makes no warranty
as to its use or performance.  @sofa{} does not and cannot warrant the
performance or results which the user may obtain by using the @sofa{}
software.  @sofa{} makes no warranties, express or implied, as to
non-infringement of third party rights, merchantability, or fitness for
any particular purpose.  In no event will @sofa{} be liable to the user
for any consequential, incidental, or special damages, including any
lost profits or lost savings, even if a @sofa{} representative has been
advised of such damages, or for any claim by any third party.

@item
The provision of any version of the @sofa{} software under the terms and
conditions specified herein does not imply that future versions will
also be made available under the same terms and conditions.
@end enumerate

Correspondence concerning @sofa{} software should be addressed as follows:

@itemize
@item
By e-mail: @email{sofa@@ukho.gov.uk}.

@item
By post:

@quotation
IAU @sofa{} Center@*
HM Nautical Almanac Office@*
UK Hydrographic Office@*
Admiralty Way@*
Taunton, TA1 2DN@*
United Kingdom
@end quotation
@end itemize

@c ------------------------------------------------------------

@appendixsec Acknowledgement & Citation for @sofa{}

If your use of @sofa{} results in a publication, presentation or
product, please include a citation.  Evidence of your use of the @sofa{}
libraries is necessary to ensure continuing support of the initiative.

The following is a suitable form of words: ``Software Routines from the
IAU @sofa{} Collection were used.  Copyright @copyright{} International
Astronomical Union Standards of Fundamental Astronomy
(@url{http://www.iausofa.org})''.

@c page
@node references
@appendix Bibliography and references


The package is distributed under the terms of the International
Astronomical Union's @sofa{} license and its development takes place at:

@center @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}

@noindent
and as backup at:

@center @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/}

@noindent
proper release tarballs are available from:

@center @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}

@noindent
the International Astronomical Union's @sofa{} project home page is at:

@center @url{http://www.iausofa.org/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
